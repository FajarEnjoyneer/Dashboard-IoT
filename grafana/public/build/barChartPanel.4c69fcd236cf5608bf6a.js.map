{"version":3,"file":"barChartPanel.4c69fcd236cf5608bf6a.js","mappings":"qKAkBO,MAAMA,EAAoB,CAAC,CAChC,MAAAC,EACA,SAAAC,EACA,SAAAC,EACA,WAAAC,EAAa,GACb,UAAAC,CACF,IAA8B,CAC5B,MAAMC,KAAS,MAAWC,CAAS,EAE7BC,GAAiCJ,EACnC,CACE,UAAAC,EACA,UAAW,MACb,EACA,CAAC,EAEL,SACE,QAAC,OAAI,UAAWC,EAAO,QAAS,MAAOE,GACpC,UAAAP,EAAM,IAAI,CAAC,CAAE,MAAAQ,GAAO,MAAAC,GAAO,MAAAC,EAAO,eAAAC,EAAgB,eAAAC,EAAgB,SAAAC,EAAU,UAAAC,CAAU,EAAGC,OACxF,OAAC,KAEC,MAAAP,GACA,MAAAC,GACA,MAAAC,EACA,eAAAC,EACA,eAAAC,EACA,SAAAC,EACA,QAAS,gBACT,SAAAX,EACA,UAAAY,EACA,gBAAiB,CAACX,CAAA,EAVbY,CAWP,CACD,EACAd,CAAA,EACH,CAEJ,EAEMK,EAAaU,IAA0B,CAC3C,WAAS,OAAI,CACX,QAAS,OACT,cAAe,SACf,KAAM,EACN,IAAK,EACL,UAAW,aAAaA,EAAM,OAAO,OAAO,IAAI,GAChD,QAASA,EAAM,QAAQ,CAAC,CAC1B,CAAC,CACH,E,oFCpDO,MAAMC,EAAmB,CAAC,CAAE,KAAAC,EAAM,SAAAhB,CAAS,IAAa,CAC7D,MAAMG,KAAS,MAAWC,CAAS,EAE7B,CAAE,MAAAE,EAAO,MAAAC,EAAO,MAAAC,EAAO,eAAAC,EAAe,EAAIO,EAEhD,SACE,OAAC,OAAI,UAAWb,EAAO,QACrB,mBAAC,KACC,MAAAG,EACA,MAAAC,EACA,MAAAC,EACA,eAAAC,GACA,YAAa,OACb,SAAAT,CAAA,CACF,EACF,CAEJ,EAEMI,EAAaU,IAA0B,CAC3C,WAAS,OAAI,CACX,QAAS,OACT,cAAe,SACf,KAAM,EACN,QAASA,EAAM,QAAQ,CAAC,EACxB,WAAY,CACd,CAAC,CACH,E,sJC7BYG,GAAAA,IACVA,EAAAA,EAAA,qBACAA,EAAAA,EAAA,uBAFUA,IAAAA,GAAA,IAcL,MAAMC,EAA2B,CAAC,CACvC,MAAAV,EAAQ,IACR,eAAAC,EAAiB,KACjB,SAAAU,EAAW,EACX,UAAAP,CACF,IAAa,CACX,MAAMT,KAAS,MAAWC,EAAS,EAEnC,OAAIK,IAAmB,KAAe,UAElC,OAACW,EAAA,GACC,MAAAZ,EACA,UAAAI,EACA,UAAWO,IAAa,EAAiChB,EAAO,QAAUA,EAAO,SACnF,KAKF,OAAC,QACC,MAAO,CAAE,gBAAiBK,CAAM,EAChC,aAAW,MACTW,IAAa,EAAiChB,EAAO,QAAUA,EAAO,YACtE,MAAuBM,EAAgBN,CAAM,CAC/C,EACF,CAEJ,EAGMC,GAAaU,IAA0B,CAC3C,WAAS,OAAI,CACX,YAAaA,EAAM,QAAQ,EAAG,CAChC,CAAC,EACD,YAAU,OAAI,CACZ,WAAYA,EAAM,QAAQ,EAAG,CAC/B,CAAC,EACD,SAAO,OAAI,CACT,MAAO,OACP,OAAQ,OACR,aAAcA,EAAM,MAAM,OAAO,QACjC,WAAY,IACZ,SAAU,MACZ,CAAC,EACD,WAAS,OAAI,CAAC,CAAC,EACf,WAAS,OAAI,CAAC,CAAC,EACf,WAAS,OAAI,CAAC,CAAC,EACf,WAAS,OAAI,CAAC,CAAC,EACf,aAAW,OAAI,CACb,MAAO,MACP,OAAQ,MACR,aAAcA,EAAM,MAAM,OAAO,OACjC,SAAU,KACZ,CAAC,EACD,aAAW,OAAI,CACb,MAAO,MACP,OAAQ,MACR,aAAcA,EAAM,MAAM,OAAO,OACjC,SAAU,KACZ,CAAC,EACD,aAAW,OAAI,CACb,MAAO,OACP,OAAQ,OACR,aAAcA,EAAM,MAAM,OAAO,OACjC,SAAU,MACZ,CAAC,CACH,GCrEA,IAAKO,IAAAA,IACHA,EAAA,MAAQ,QACRA,EAAA,MAAQ,QAFLA,IAAAA,IAAA,IAKL,MAAMC,GAA2B,sBAC3BC,EAAwB,EAAI,IAC5BC,EAAyB,EAElBC,EAAgB,CAAC,CAC5B,MAAAnB,EACA,MAAAC,EACA,MAAAC,EACA,eAAAC,EACA,eAAAC,EAAiB,KAAe,MAChC,QAAAgB,EAAU,aACV,SAAAf,EAAW,GACX,YAAAgB,GAAc,MACd,SAAA3B,GACA,UAAAY,GACA,gBAAAgB,CACF,IAA0B,CACxB,MAAMzB,KAAS,MAAW,EAAWuB,EAASC,EAAW,EAEnDE,GAAuCD,EACzC,CACE,UAAW,GACX,WAAY,OACZ,UAAW,aACX,UAAW,MACb,EACA,CACE,WAAY,WACZ,UAAW,aACX,WAAY,GACd,EAEE,CAACE,GAAkBC,CAAmB,KAAI,YAAS,EAAK,EAExD,CAACC,GAAYC,EAAa,KAAI,YAAwC,IAAI,EAC1E,CAACC,GAAiBC,EAAkB,KAAI,YAAS,EAAK,EAEtDC,KAAW,UAA8B,IAAI,EAC7CC,KAAW,UAA8B,IAAI,KAEnD,aAAU,IAAM,CACd,IAAIC,GAEJ,OAAIJ,KACFI,GAAY,WAAW,IAAM,CAC3BH,GAAmB,EAAK,CAC1B,EAAGZ,CAAqB,GAGnB,IAAM,CACX,OAAO,aAAae,EAAS,CAC/B,CACF,EAAG,CAACJ,EAAe,CAAC,EAEpB,MAAMK,GAAkB,MAAOC,GAAcC,KAA0B,CACrE,GAAI,EAAE,WAAW,WAAa,OAAO,iBAAkB,CACrDC,GAAwBF,GAAMC,EAAI,EAClC,MACF,CAEA,GAAI,CACF,MAAM,UAAU,UAAU,UAAUD,EAAI,EACxCP,GAAc,CAAE,CAAC,GAAGQ,EAAI,EAAE,EAAGD,EAAK,CAAC,EACnCL,GAAmB,EAAI,CACzB,MAAgB,CACdF,GAAc,IAAI,CACpB,CACF,EAEMS,GAA0B,CAACF,GAAcC,KAA0B,CAEvE,MAAME,GAAW,SAAS,cAAc,UAAU,EAClDP,EAAS,SAAS,YAAYO,EAAQ,EACtCA,GAAS,MAAQH,GACjBG,GAAS,MAAM,EACfA,GAAS,OAAO,EAChB,GAAI,CACiB,SAAS,YAAY,MAAM,IAE5CV,GAAc,CAAE,CAAC,GAAGQ,EAAI,EAAE,EAAGD,EAAK,CAAC,EACnCL,GAAmB,EAAI,EAE3B,OAASS,GAAK,CACZ,QAAQ,MAAM,8BAA+BA,EAAG,CAClD,CAEAD,GAAS,OAAO,CAClB,EAEME,GAAqBC,IAA4C,CACjEA,GAAM,cAAc,YAAcA,GAAM,cAAc,aACxDf,EAAoB,EAAI,CAE5B,EAEMgB,GAAoB,IAAMhB,EAAoB,EAAK,EAGzD,OAAIzB,EAAM,OAASkB,EAAyB,OAAO,WAAa,IAC9DlB,EAAQA,EAAM,WAAW,IAAK;AAAA,GAAO,EAAE,WAAW,IAAK;AAAA,EAAK,EAAE,WAAW,KAAM;AAAA,GAAO,MAItF,QAAC,OAAI,UAAWH,EAAO,eACnB,WAAAK,GAASF,OACT,QAAC,OAAI,UAAWH,EAAO,aACpB,UAAAK,GAASE,IAAmB,KAAe,UAC1C,OAACQ,EAAwB,CAAC,MAAAV,EAAc,eAAAC,EAAgC,UAAAG,EAAA,CAAsB,EAE9FZ,MAGA,mBACE,mBAACgD,EAAA,EAAO,CAAC,QAAS1C,EAAO,YAAa,GAAO,KAAMwB,GACjD,gCACG,UAAAI,IAAmBF,IAAY,UAC9B,OAACiB,EAAA,EAAW,CAAC,UAAU,MAAM,iBAAkBb,EAAS,QACrD,SAAAd,EAAA,CACH,KAGF,OAAC,OACC,aAAW,MAAGnB,EAAO,MAAOQ,GAAYR,EAAO,aAAc,WAAW,WAAaA,EAAO,IAAI,EAChG,aAAc0C,GACd,aAAcE,GACd,QAAS,IAAMR,GAAgBjC,EAAO,OAAqB,EAC3D,IAAK8B,EAEJ,SAAA9B,CAAA,CACH,GACF,EACF,EACF,KAtBA,OAAC,OAAI,aAAW,MAAGH,EAAO,MAAOQ,GAAYR,EAAO,YAAY,EAAI,SAAAG,CAAA,CAAM,CAsB1E,EAEJ,KAGF,QAAC,OAAI,UAAWH,EAAO,aACpB,UAAAK,GAASE,IAAmB,KAAe,YAC1C,OAACQ,EAAA,CACC,MAAAV,EACA,eAAAC,EACA,SAAUQ,EAAuB,QACjC,UAAAL,EAAA,CACF,EAGAZ,MAKA,oBACG,UAAAkC,IAAmBF,IAAY,UAC9B,OAACiB,EAAA,EAAW,CAAC,UAAU,MAAM,iBAAkBZ,EAAS,QACrD,SAAAf,EAAA,CACH,KAGF,OAAC,OACC,aAAW,MAAGnB,EAAO,MAAOQ,EAAU,WAAW,WAAaR,EAAO,IAAI,EACzE,MAAO0B,GACP,QAAS,IAAMU,GAAgBhC,EAAQA,EAAM,SAAS,EAAI,GAAI,OAAqB,EACnF,IAAK8B,EAEJ,SAAA9B,CAAA,CACH,GACF,KAnBA,OAAC,OAAI,aAAW,MAAGJ,EAAO,MAAOQ,CAAQ,EAAG,MAAOkB,GAChD,SAAAtB,CAAA,CACH,EAoBDC,GAASE,IAAmB,KAAe,aAC1C,OAACQ,EAAA,CACC,MAAAV,EACA,eAAAC,EACA,SAAUQ,EAAuB,SACjC,UAAAL,EAAA,CACF,GAEJ,GACF,CAEJ,EAEM,EAAY,CAACE,EAAsBY,EAAiBC,KAAyB,CACjF,kBAAgB,OAAI,CAClB,QAAS,OACT,WAAY,QACZ,eAAgBD,EAChB,YAAAC,CACF,CAAC,EACD,SAAO,OAAI,CACT,MAAOb,EAAM,OAAO,KAAK,UACzB,WAAY,IACZ,aAAc,WACd,SAAU,SACV,YAAaA,EAAM,QAAQ,CAAC,CAC9B,CAAC,EACD,SAAO,OAAI,CACT,WAAY,IACZ,aAAc,WACd,SAAU,QACZ,CAAC,EACD,gBAAc,OAAI,CAChB,QAAS,OACT,WAAY,QACd,CAAC,EACD,gBAAc,OAAI,CAChB,WAAYA,EAAM,WAAW,eAC7B,MAAOA,EAAM,OAAO,KAAK,WAC3B,CAAC,EACD,QAAM,OAAI,CACR,OAAQ,SACV,CAAC,CACH,E,sJCzNO,MAAMoC,EAAuB,CAClCC,EACAC,EACAC,IAEO,CAAC9C,EAAO+C,EAAYC,KACrBH,EAAO,WAAaC,IACtB9C,EAAQA,EAAM,QAAQ,SAAWiD,GAAY,CAC3C,MAAMC,EAAOD,EAAQ,MAAM,CAAC,EAE5B,OAAIJ,EAAO,UAAW,KAAMA,GAAWA,EAAO,MAAQK,CAAI,GAAKJ,EAAWI,CAAI,GAAK,KAC1EJ,EAAWI,CAAI,EAGjBD,CACT,CAAC,GAGIL,EAAsB5C,EAAO+C,EAAYC,CAAM,GAK7CG,EAAa,CACxBC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEI,CAACD,GAAWA,EAAQ,SAAW,EAC1B,CAAC,EAGWA,EAAQ,IAAKX,GAAmB,CACnD,MAAMa,KAAoC,MAAyBN,EAAOC,EAAOC,CAAe,EAC1FK,EAAmB,CACvB,GAAGL,EACH,cAAeI,CACjB,EAEMd,EAA6C,CAAC5C,GAAO+C,GAAYC,IAC9DO,EAAiBvD,GAAO,CAAE,GAAG2D,EAAkB,GAAGZ,EAAW,EAAGC,CAAM,EAI/E,OAAIS,EAAO,gBAAkB,QAAa,CAAC,MAAMA,EAAO,aAAa,EACnEC,EAAY,MAAM,SAAWD,EAAO,cAEpCC,EAAY,MAAM,gBAAkBD,EAAO,gBAGL,CACtC,MAAOF,EAAiBV,EAAO,MAAOc,CAAgB,EACtD,aAAeb,IACbH,EACEC,EACAC,EACAC,EACF,EAAED,EAAO,cAAgB,4BAA4BA,EAAO,KAAK,GAAG,EACtE,QAAS,CAACe,GAAiBC,GAAef,IAAqC,CAC7E,IAAIgB,EAAUC,EAAmBlB,EAAQF,EAAqBC,EAAuBC,EAAQC,CAAU,CAAC,EAExG,GAAI,IACF,MAAc,EACX,MAAMgB,CAAO,EACb,UAAU,CACT,MAAQE,IAAU,CAChB,KAAU,KAAK,KAAU,WAAY,CAAC,+DAA+D,CAAC,EACtG,QAAQ,MAAMA,EAAK,CACrB,EACA,SAAU,IAAM,CACd,KAAU,KAAK,KAAU,aAAc,CAAC,yBAAyB,CAAC,CACpE,CACF,CAAC,CACL,OAASA,GAAO,CACd,KAAU,KAAK,KAAU,WAAY,CAAC,+DAA+D,CAAC,EACtG,QAAQ,MAAMA,EAAK,EACnB,MACF,CACF,EACA,SAAUnB,EAAO,UAAY,GAC7B,MAAO,CACL,gBAAiBA,EAAO,OAAO,iBAAmB,IAAc,OAAO,OAAO,UAAU,IAC1F,EACA,UAAWA,EAAO,SACpB,CAGF,CAAC,EAEmB,OAAQA,GAAkC,CAAC,CAACA,CAAM,EAI3DkB,EAAqB,CAAClB,EAAgBU,IAA0C,CAC3F,MAAMU,EAAM,IAAI,IAAIC,GAAOX,EAAiBV,EAAO,MAAM,GAAG,CAAC,CAAC,EAExDsB,EAAyC,CAAC,EAEhD,IAAIL,EAA6B,CAC/B,IAAKG,EAAI,SAAS,EAClB,OAAQpB,EAAO,MAAM,OACrB,KAAMuB,GAAQvB,EAAQU,CAAgB,EACtC,QAASY,CACX,EAEA,OAAItB,EAAO,MAAM,SACfA,EAAO,MAAM,QAAQ,QAAQ,CAAC,CAACK,EAAMlD,CAAK,IAAM,CAC9CmE,EAAeZ,EAAiBL,CAAI,CAAC,EAAIK,EAAiBvD,CAAK,CACjE,CAAC,EAGC6C,EAAO,MAAM,cACfA,EAAO,MAAM,aAAa,QAAQ,CAAC,CAACK,EAAMlD,CAAK,IAAM,CACnDiE,EAAI,aAAa,OAAOV,EAAiBL,CAAI,EAAGK,EAAiBvD,CAAK,CAAC,CACzE,CAAC,EAED8D,EAAQ,IAAMG,EAAI,SAAS,GAG7BE,EAAe,kBAAkB,EAAI,IACrCL,EAAQ,QAAUK,EAEXL,CACT,EAIaO,GAAyB,CAACC,EAAwB,CAAC,EAAGd,EAAoB,CAAC,KAC/E,CACL,KAAM,gBACN,KAAM,KAAU,OAChB,OAAQ,CAAE,MAAOc,EAAW,QAAAd,CAAiB,EAC7C,OAAQ,CAAC,CACX,GAIIU,GAAUK,GAAqB,CAEnC,GADsBA,EAAS,WAAW,GAAG,EAC1B,CAEjB,MAAMC,EAAuB,KAAS,YAAYD,CAAQ,EAC1DA,KAAW,KAAkBC,EAAsB,CAAC,CAAC,CACvD,CAEA,OAAOD,CACT,EAGMH,GAAU,CAACvB,EAAgBU,IAA0C,CACzE,IAAIkB,EAA2B5B,EAAO,MAAM,KAAOU,EAAiBV,EAAO,MAAM,IAAI,EAAI,KACzF,OAAIA,EAAO,MAAM,SAAW,KAAkB,MAC5C4B,EAAO,QAGFA,CACT,C,4YC3JO,SAASC,GAAuBjB,EAA4BgB,EAAmB,CACpF,OAAOA,EAAK,CAAC,EAAE,OAAO,MAAM,CAAC,EAAE,KAAMpB,GAAU,CAASA,EAAM,OAAO,QAAQ,UAAU,MAAO,CAQhG,CAEO,MAAMsB,MAAiB,QAC5B,CAAC,CAAE,KAAAF,EAAM,UAAAG,EAAW,MAAAC,EAAO,YAAAC,EAAa,WAAAC,EAAY,GAAGC,CAAqB,IAA4B,CACtG,MAAMzE,KAAQ,MAAU,EAElB0E,EAAcR,EAAK,CAAC,EAAE,OAAO,CAAC,EAAE,OAChCS,GAAYD,EAAY,OAAO,KAE/BE,EAAkC,CAAC,EACzC,GAAID,KAAc,IAAiB,WAAY,CAC7C,MAAME,EAAuC,CAAE,KAAM,KAAe,SAAU,MAAO,CAAC,CAAE,EAClFC,EAAsC,CAAE,KAAM,KAAe,WAAY,MAAO,CAAC,CAAE,EAEzF,QAAS/E,GAAI,EAAGA,GAAImE,EAAK,CAAC,EAAE,OAAO,OAAQnE,KAAK,CAC9C,MAAM+C,GAAQoB,EAAK,CAAC,EAAE,OAAOnE,EAAC,EAE9B,GAAI+C,GAAM,OAAO,YAAcA,GAAM,OAAO,WAAW,MAAM,OAAS,EACpE,GAAIA,GAAM,OAAO,WAAW,OAAS,KAAe,SAClD,UAAWiC,KAAQjC,GAAM,OAAO,WAAW,SACpC,YAAS+B,EAAmB,MAAOE,CAAI,GAC1CF,EAAmB,MAAM,KAAKE,CAAI,MAItC,WAAWA,KAAQjC,GAAM,OAAO,WAAW,SACpC,YAASgC,EAAkB,MAAOC,CAAI,GACzCD,EAAkB,MAAM,KAAKC,CAAI,CAK3C,CAEA,MAAMC,MAA0C,MAAkBN,EAAa1E,EAAO6E,CAAkB,EAClGI,MAAyC,MAAkBP,EAAa1E,EAAO8E,CAAiB,EACtGF,EAAe,KAAK,GAAGI,GAAwB,GAAGC,EAAqB,CACzE,CAEA,MAAMC,GAAgC,CAAC,EACvC,QAASnF,EAAI,EAAGA,EAAImE,EAAK,CAAC,EAAE,OAAO,OAAQnE,IAAK,CAC9C,MAAMoF,EAAWjB,EAAK,CAAC,EAAE,OAAOnE,CAAC,EAAE,OAAO,SAC1C,GAAIoF,EACF,UAAWC,MAAWD,KACf,YAASD,GAAeE,EAAO,GAClCF,GAAc,KAAKE,EAAO,CAIlC,CACA,MAAMC,MAAqC,MAAqBH,GAAelF,CAAK,EAE9EsF,GAAcpB,EAAK,CAAC,EAAE,OACzB,MAAM,CAAC,EACP,IAAI,CAACpB,EAAO/C,IAAM,CAEjB,MAAMwF,GAAaxF,EAAI,EAIvB,GAAI,CAAC+C,GAASA,EAAM,OAAO,QAAQ,UAAU,OAC3C,OAKF,MAAMtD,GAAQsD,EAAM,OAAO,aAAeA,EAAM,KAE1CpD,MAAQ,OAAoBoD,EAAO9C,CAAK,EAAE,MAWhD,MAT4B,CAC1B,SAAU8C,EAAM,OAAO,UAAU,IACjC,MAAApD,GACA,MAAAF,GACA,MAAOsD,EAAM,OAAO,QAAQ,gBAAkB,KAAc,MAAQ,EAAI,EACxE,iBAAkB,OAAM,MAAyBwB,EAAOxB,EAAO9C,CAAK,EACpE,WAAY,IAAM,GAAGR,EAAK,MAAkB+F,EAAU,EACxD,CAGF,CAAC,EACA,OAAQxF,GAA0BA,IAAM,MAAS,EAEpD,SACE,OAACyF,EAAA,GAAU,OAAV,CAAiB,UAAAnB,EAAuB,GAAGI,EAC1C,mBAACgB,GAAA,GACC,UAAApB,EACA,MAAOiB,GACP,eAAAV,EACA,aAAcS,GACd,YAAAd,EACA,OAAQE,EAAqB,OAC7B,SAAUA,EAAqB,SAC/B,WAAY,GACd,EACF,CAEJ,CACF,EAEAL,GAAe,YAAc,iB,sKC1H7B,MAAMsB,GAAY,MAAkB,SAK9BC,GAAa,MACbC,GAAW,MAEXC,GAAsB,EACtBC,GAAsB,GAEtBC,GAAsB,IAEtBC,GAAyB,GACzBC,GAAyB,IAEzBC,GAAsB,EACtBC,GAAsB,GAKtBC,GAAwB,GA0D9B,SAASC,GACP3E,EACA4E,EACAC,EACAC,EACAC,EACA,CAEA,MAAMC,KAAWC,EAAA,IAAYjF,EAAM,EAAE,EAE/BkF,EAAwBN,GAASI,EAAS,MAAQ,GAAM,GACxDG,EAAwBN,EAASC,EAGjCM,GAAc,KAAK,IAAID,EAAuBD,CAAoB,EACxE,MAAO,CACL,SAAU,KAAK,IAAIE,GAAaL,GAAWK,EAAW,EACtD,YAAaJ,CACf,CACF,CAKO,SAASK,GAAUC,EAAmBhH,EAAsB,CACjE,KAAM,CACJ,KAAAiH,EACA,KAAMC,EACN,SAAAC,EACA,SAAAC,EACA,YAAAC,EACA,iBAAAC,EACA,YAAAC,GAAc,EACd,UAAAC,EACA,SAAAC,GAAW,EACX,WAAAC,GAAa,GACb,SAAAC,GAAW,SACb,EAAIX,EACEY,EAAgBX,IAAS,KAAiB,WAC1CY,EAAmB,CAASb,EAAK,MAAM,UACvCc,GAAYd,EAAK,WAAa,KAAa,KAC3Ce,GAAaf,EAAK,WAAa,KAAa,QAElD,GAAI,CAAE,WAAAgB,GAAY,SAAAC,GAAU,UAAAC,EAAY,CAAE,EAAIlB,EAE1Cc,KACF,CAACE,GAAYC,EAAQ,EAAI,CAACA,GAAUD,EAAU,GAGhD,IAAIG,EAEJ,MAAMC,GAA8B,MADlB,EACiC,EAAE,KAAK,IAAI,EAC9D,IAAIC,GAGJ,MAAMC,GAAoC,GAAM,MAAM,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAACC,EAAGxI,IAAMA,CAAC,CAAC,EAE/EyI,GACJf,KAAa,EACT,OACA,CAAC,EAAGgB,IAAW,CAEb,MAAMC,EAAM,EAAE,KAAK,MACbC,EAAOzB,GAAOU,EAAgB,EAAI,IAExC,IAAIgB,EAAUH,EAAO,OACjBI,EAAUD,EAAU,EAEpBE,EAAU,EAEVC,GAASL,EAAM,IAAM,QACrBM,GAAW,KAAK,IAAI,KAAK,MAAMD,GAAStB,EAAQ,CAAC,EAErDqB,EAAUF,EAAUI,GAAW,EAAI,KAAK,KAAKJ,EAAUI,EAAQ,EAE/D,IAAIC,GAAUR,EAAO,IAAI,CAACF,GAAGxI,KACV+I,IAAY,IAAMrB,GAAW,EAAI1H,GAAI8I,EAAU9I,IAAK+I,EAAU,EAC3D,KAAOP,EAC5B,EAED,OAAOI,IAAS,EAAIM,GAAUA,GAAQ,QAAQ,CAChD,EAGAC,GAAuB,CAAC,EAAGT,EAAQU,EAASC,EAAYC,IAAc,CAC1E,GAAIrC,EAAK,UAAW,CAClB,IAAIvE,EAASiD,GAAU,KAEvB,OAAI2D,EAAY,KAAa,OAC3B5G,EAASiD,GAAU,YACV2D,EAAY,KAAa,OAClC5G,EAASiD,GAAU,OACV2D,EAAY,KAAa,KAClC5G,EAASiD,GAAU,OACV2D,EAAY,KAAa,IAClC5G,EAASiD,GAAU,KACV2D,EAAY,KAAa,MAClC5G,EAASiD,GAAU,IACV2D,EAAY,KAAa,KAClC5G,EAASiD,GAAU,MAEnBjD,EAASiD,GAAU,KAGd+C,EAAO,IAAKF,GAAOA,GAAK,KAAO,MAAK,OAAeA,EAAG,CAAE,OAAA9F,EAAQ,SAAAkF,EAAS,CAAC,CAAE,CACrF,CAEA,OAAOc,EAAO,IAAKF,GAAOX,EAAgBN,EAAiB,EAAGiB,CAAC,EAAIlB,EAAY,EAAGkB,CAAC,CAAE,CACvF,EAGMe,GAAsB,CAAC,EAAGC,EAAKC,IAAQ,CAC3CD,EAAM,EACNC,EAAM,KAAK,IAAI,EAAG,EAAE,KAAK,CAAC,EAAE,OAAS,CAAC,EAEtC,IAAIC,EAAY,KAGhBC,GAAA,IAAW,EAAE,KAAK,CAAC,EAAE,OAAQ1B,GAAYrC,GAAY,EAAG,CAACgE,EAAIC,EAAQC,KAAW,CAC9EJ,EAAYG,EAASC,GAAS,CAChC,CAAC,EAGD,IAAIC,EAAKN,EAAMD,EAEf,GAAIE,IAAc,GAChBF,GAAOO,MACF,CAEL,IAAIC,GADU,GAAK,EAAIN,EAAY,GACXK,EAAKA,GAAM,EAEnCP,GAAOQ,EACPP,GAAOO,CACT,CAEA,MAAO,CAACR,EAAKC,CAAG,CAClB,EAEA,IAAIQ,GAAW,CAACC,EAAoBC,IAAqB,CACvD,IAAIC,EAAM,MAAM,KAAK,CAAE,OAAQD,CAAS,EAAG,KAAO,CAChD,KAAM,MAAMD,CAAU,EAAE,KAAK,CAAC,EAC9B,KAAM,MAAMA,CAAU,EAAE,KAAK,CAAC,CAChC,EAAE,EAEF,SAAAP,GAAA,IAAWO,EAAYjC,GAAYrC,GAAY,KAAM,CAACyE,EAAUC,EAAaC,IAAgB,IAC3FZ,GAAA,IAAWQ,EAAUjC,GAAUrC,GAAU,KAAM,CAAC2E,EAAQC,GAAWC,KAAc,CAC/EN,EAAII,CAAM,EAAE,KAAKH,CAAQ,EAAIC,EAAcC,EAAcE,GACzDL,EAAII,CAAM,EAAE,KAAKH,CAAQ,EAAIE,EAAcG,EAC7C,CAAC,CACH,CAAC,EAEMN,CACT,EAEIO,GAAW,CAACT,EAAoBC,IAAqB,CACvD,IAAIC,EAAM,MAAM,KAAK,CAAE,OAAQD,CAAS,EAAG,KAAO,CAChD,KAAM,MAAMD,CAAU,EAAE,KAAK,CAAC,EAC9B,KAAM,MAAMA,CAAU,EAAE,KAAK,CAAC,CAChC,EAAE,EAEF,SAAAP,GAAA,IAAWO,EAAYjC,GAAYrC,GAAY,KAAM,CAACyE,EAAUC,EAAaC,IAAgB,IAC3FZ,GAAA,IAAWQ,EAAUjC,GAAUrC,GAAU,KAAM,CAAC2E,EAAQC,GAAWC,KAAc,CAC/EN,EAAII,CAAM,EAAE,KAAKH,CAAQ,EAAIC,EAC7BF,EAAII,CAAM,EAAE,KAAKH,CAAQ,EAAIE,CAC/B,CAAC,CACH,CAAC,EAEMH,CACT,EAEA,MAAMQ,GAAsB/C,EAAgB5B,GAAyBC,GAC/D2E,GAAmBhD,EAAgB1B,GAAsBC,GAE/D,IAAI0E,GAAkE,CAAC,EACnEC,EAAyF,CAAC,EAC1FC,EAAc,EACdC,EACAC,EAAWjE,EAAK,MAAM,WAAalB,GACnCoF,GAAcN,GAGdO,GAAS,IACTC,GAAS,IAETC,GAAkBjE,GAAY,KAE9BkE,GAAkBD,GAClB,CACE,KAAM,CACJ,KAAM,EACN,OAAQ,CAAC,EAAUE,IAAsBT,EAAWS,CAAS,EAAG,IAClE,EACA,OAAQ,CACN,KAAM,EACN,OAAQ,CAAC,EAAUA,IAAsBT,EAAWS,CAAS,EAAG,MAClE,CACF,EACA,CAAC,EAEDC,GAAc,IAAM,MAAM,KAAM,CAClC,OAAQzD,GACJ,EACCD,GAEC,CAAC,EAAUyD,IACaA,IAAc,EAAE,KAAK,OAAS,EAC3B,CAACrD,EAAW,CAAC,EAAI,CAAC,EAAG,CAAC,EAHjDA,EAKN,KAAM,CACJ,GAAI,CACF,KAAM,EACN,OAAQ,CAAC,EAAGqD,IAAcV,GAAcU,CAAS,EAAG,IACtD,EACA,KAAM,CACJ,KAAM,EACN,OAAQ,CAAC,EAAGA,IAAcV,GAAcU,CAAS,EAAG,IACtD,EACA,GAAGD,EACL,EAEA,KAAM,CAAC,EAAGC,EAAWE,EAASC,EAAKC,EAAKC,EAAKC,IAAQ,CAGnDH,GAAO,EAAE,KAAK,KACdC,GAAO,EAAE,KAAK,IAEd,IAAIG,GAAM,EAAE,KAAKP,CAAS,EAAEE,CAAO,EAE/B7D,GACFuD,GAAS,KAAK,IAAIA,GAAQW,GAAM,EAAI,EAAE,KAAK,QAAUH,EAAME,GAAOF,CAAG,EACrEP,GAASQ,IAETT,GAASU,EACTT,GAAS,KAAK,IAAIA,GAAQU,GAAM,EAAIJ,EAAM,EAAE,KAAK,OAASA,EAAME,EAAI,GAGtE,IAAIG,GAAU,CAAE,EAAGL,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAAGC,EAAK,KAAMN,EAAW,KAAME,CAAQ,EAc/E,GAZI,CAAC3D,IAAad,EAAK,gBACjBA,EAAK,OAAS,KAAiB,YACjC+E,GAAQ,EAAI,EACZA,GAAQ,EAAI,EAAE,KAAK,SAEnBA,GAAQ,EAAI,EACZA,GAAQ,EAAI,EAAE,KAAK,QAIvB5D,EAAG,IAAI4D,EAAO,EAEVvE,IAAc,KAAe,MAAO,CACtC,MAAMwE,GAAM7E,EAASoE,EAAWE,CAAO,EACvC,IAAIQ,GAAU,EAEVlE,IAAcmE,GAAeX,CAAS,EAAEE,CAAO,IACjDQ,GAAUC,GAAeX,CAAS,EAAEE,CAAO,GAG7C,MAAMlD,GAAI0D,KAAY,EAAI,EAAID,GAAMC,GAE9BvK,GAAO2F,EAAYkE,EAAWhD,EAAC,EASrC,GARA2C,GAAc,KAAK,IAAIA,GAAa,KAAK,MAAMP,IAAuB/C,EAAgBgE,EAAMC,EAAI,CAAC,EAE7Fb,EAAOS,CAAO,IAAM,SACtBT,EAAOS,CAAO,EAAI,CAAC,GAErBT,EAAOS,CAAO,EAAEF,CAAS,EAAI,CAAE,KAAA7J,GAAY,MAAOyF,EAASoE,EAAWE,CAAO,EAAG,OAAQ,EAAM,EAG1F5D,EAAkB,CACpB,KAAM,CAAE,SAAUsE,GAAgB,YAAAC,EAAY,EAAI/F,GAChD2E,EAAOS,CAAO,EAAEF,CAAS,EAAE,KAC3BH,IAAUxD,EAAgB7B,GAAsB,IAAM6B,EAAgB,EAAIsD,IAC1EC,IAAUvD,EAAgB,EAAI7B,KAAwB6B,EAAgBsD,GAAc,GACpF,CACF,EAGAF,EAAOS,CAAO,EAAEF,CAAS,EAAE,YAAca,GAGzC,IAAIC,GAAe,KAAK,MAAM,KAAK,IAAIpB,EAAUnF,GAAqBqG,EAAc,CAAC,EAKrFpB,EAAesB,GAAepB,GAAaoB,GAAe,IAG1DpB,EAAWoB,EACb,MACErB,EAAOS,CAAO,EAAEF,CAAS,EAAE,eAAc5E,EAAA,IAAYqE,EAAOS,CAAO,EAAEF,CAAS,EAAE,KAAMN,CAAQ,EAGhG,IAAIqB,GAAc1E,EAAgB,EAAI,CAAC,KAAK,MAAMxB,GAAwB6E,CAAQ,EAC9ExL,GAAQ0H,EAASoE,EAAWE,CAAO,EAMvC,GAJIzE,EAAK,OAAOuE,CAAS,GAAK9L,IAAS,OACrCA,IAAS,IAGPA,IAAS,KAAM,CAEjB,MAAM8M,GACJ,EAAE,KAAK,MAAQ3E,EAAgB8D,EAAME,EAAM,EAAInM,GAAQ,EAAIiM,EAAMR,GAAcQ,EAAME,EAAMV,IAC7F,IAAIsB,GACF,EAAE,KAAK,KACN5E,EAAiBnI,GAAQ,EAAIkM,EAAME,EAAMX,GAAcS,EAAMT,GAAeS,EAAME,EAAM,EAAIS,IAK/F,KAAM,CACJ,YAAAF,GAAc,CACZ,MAAO,EACP,wBAAyB,EACzB,yBAA0B,CAC5B,CACF,EAAIpB,EAAOS,CAAO,EAAEF,CAAS,EAI7B,IAAIkB,GAAU,EACZC,GAAU,EAER9E,GAEF6E,GAAWL,GAAY,MAAQrB,EAAe,EAG9C2B,GACEjN,GAAQ,GACH2M,GAAY,wBAA0BA,GAAY,0BAA4BrB,EAC/E,IAGN2B,IAAYN,GAAY,wBAA0BA,GAAY,0BAA4BrB,EAAe,EAGzG0B,GAAUhN,GAAQ,EAAI2M,GAAY,MAAQrB,EAAc,GAItDyB,GAAIE,GAAU,IAChBF,GAAIE,IAIN1B,EAAOS,CAAO,EAAEF,CAAS,EAAE,EAAIgB,GAC/BvB,EAAOS,CAAO,EAAEF,CAAS,EAAE,EAAIiB,GAC/BxB,EAAOS,CAAO,EAAEF,CAAS,EAAE,KAAO,CAChC,EAAGgB,GAAIE,GACP,EAAGD,GAAIE,GACP,EAAGN,GAAY,MAAQrB,EACvB,GAAIqB,GAAY,wBAA0BA,GAAY,0BAA4BrB,CACpF,CACF,CACF,CACF,CACF,CAAC,EAED,MAAM4B,GAAQ,GAAa,CACzB,EAAE,KAAK,iBAAiC,cAAc,EAAE,QAASC,GAAO,CACtEA,EAAG,MAAM,aAAe,IAEpB5F,EAAK,gBACP4F,EAAG,MAAM,OAAS,KAEtB,CAAC,CACH,EAEMC,GAAuB,CAC3B,EAAG,GACH,EAAG,GACH,KAAM,CACJ,EAAG,GACH,EAAG,EACL,EACA,QAAS,CAAC,EAAGtB,IAAc,CACzB,GAAIA,IAAc,EAAG,CACnBnD,GAAQ,KAAK,IAAI,EACjBC,GAAQ,KAER,IAAIyE,EAAK,EAAE,OAAO,KAAQ,IAAM,QAC5BC,EAAK,EAAE,OAAO,IAAO,IAAM,QAE/B5E,EAAG,IAAI2E,EAAIC,EAAI,EAAG,EAAIC,GAAM,IACtB,OAAYF,EAAIC,EAAIC,EAAE,EAAGA,EAAE,EAAGA,EAAE,EAAIA,EAAE,EAAGA,EAAE,EAAIA,EAAE,CAAC,IACpD3E,GAAQD,GAAQ,CAAC,EAAI4E,EACrB5E,GAAQC,GAAM,IAAI,EAAIA,GAEtBX,OACE,OAAUS,EAAI,OAAWE,GAAM,IAAI,EAAE,QAAS4E,GAAM,CAClD7E,GAAQ6E,EAAE,IAAI,EAAIA,CACpB,CAAC,EAEP,CAAC,CACH,CAEA,OAAO7E,GAAQmD,CAAS,GAAG,IAC7B,EACA,OAAQ,CACN,KAAM,wBACN,KAAM,CAAC,EAAGA,IAAc,CACtB,IAAI2B,EAAS9E,GAAQmD,CAAS,EAC1B4B,EAAYD,GAAU,KAE1B,MAAO,CACL,KAAMC,EAAYD,EAAQ,EAAI,IAAM,QAAU,IAC9C,IAAKC,EAAYD,EAAQ,EAAI,IAAM,QAAU,IAC7C,MAAOC,EAAYD,EAAQ,EAAI,IAAM,QAAU,EAC/C,OAAQC,EAAYD,EAAQ,EAAI,IAAM,QAAU,CAClD,CACF,CACF,EACA,MAAO,CACL,KAAM,IACN,KAAM,CAAC,EAAG3B,IAAelD,IAAO,OAASkD,EAAY,EAAI,GAC3D,CACF,EAGM6B,GAAa,GAAa,CAgB9B,GAfAjF,EAAKA,GAAM,IAAI,MAAS,EAAG,EAAG,EAAE,KAAK,MAAO,EAAE,KAAK,MAAM,EACzDA,EAAG,MAAM,EAGT,EAAE,OAAO,QAASkF,GAAM,CAEtBA,EAAE,OAAS,IACb,CAAC,EAEGvF,GACF+C,GAAgB,CAAC,KAAM,GAAGH,GAAS,EAAE,KAAK,CAAC,EAAE,OAAQ,EAAE,KAAK,OAAS,CAAC,CAAC,EAEvEG,GAAgB,CAAC,KAAM,GAAGb,GAAS,EAAE,KAAK,CAAC,EAAE,OAAQ,EAAE,KAAK,OAAS,CAAC,CAAC,EAGrEqB,GAAiB,CACnBP,EAAa,CAAC,IAAI,EAGlB,QAAS/K,EAAI,EAAGA,EAAI,EAAE,KAAK,OAAQA,IAAK,CACtC,IAAIuN,EAAU,EAAE,KAAKvN,CAAC,EAA2B,IAAI,CAACN,EAAO8N,IACvD9N,GAAS,KACJ2H,EAAUrH,EAAGwN,EAAU9N,CAAK,EAG9B,IACR,EAEDqL,EAAW,KAAK,CACd,KACEvD,GAAc,EAAI+F,EAAO,IAAKE,GAAOA,GAAK,KAAOC,GAAA,GAAiB,MAAMD,EAAGjG,EAAW,EAAI,IAAK,EAAI+F,EACrG,OAAQA,CACV,CAAC,CACH,CACF,CAEAtC,EAAS,CAAC,EACVC,EAAWjE,EAAK,MAAM,WAAalB,GACnCoF,GAAcN,GACdO,GAASC,GAAS,GACpB,EAGMsC,GAAQ,GAAa,CACzB,GAAIlG,IAAc,KAAe,OAASyD,EAAWpF,GACnD,OAGF,EAAE,IAAI,KAAK,EACX,EAAE,IAAI,UAAY7F,EAAM,OAAO,KAAK,QACpC,EAAE,IAAI,KAAO,GAAGiL,CAAQ,MAAMjL,EAAM,WAAW,UAAU,GAEzD,IAAI2N,EACFC,EAEF,UAAWC,KAAQ7C,EAAQ,CAEzB,IAAI8C,EAAQ,GAEZ,UAAWC,KAAQ/C,EAAO6C,CAAI,EAAG,CAC/B,MAAMrO,EAAQwL,EAAO6C,CAAI,EAAEE,CAAI,EACzB,CAAE,KAAArM,GAAM,EAAA6K,GAAI,EAAG,EAAAC,GAAI,CAAE,EAAIhN,EAC/B,GAAI,CAAE,MAAAC,EAAM,EAAID,EAEZwH,EAAK,OAAO+G,CAAI,GAAKtO,IAAS,OAChCA,IAAS,IAGX,IAAIuO,GAAyBpG,EAAgB,SAAWnI,KAAU,MAAQA,GAAQ,EAAI,QAAU,OAC5FwO,GAA+BrG,EAC/BnI,KAAU,MAAQA,GAAQ,EACxB,MACA,aACF,SAUJ,GARIuO,KAAUL,IACZ,EAAE,IAAI,UAAYA,EAAWK,IAG3BC,KAAaL,IACf,EAAE,IAAI,aAAeA,EAAcK,IAGjCzG,IAAc,KAAe,OAC/B,EAAE,IAAI,SAAS9F,GAAM6K,GAAGC,EAAC,UAChBhF,IAAc,KAAe,KAAM,CAC5C,GAAI,CAAE,KAAA0G,EAAK,EAAI1O,EAEX2O,GAAkB,GAEtB,GAAID,IAAQ,KACVC,GAAkB,GAClB3O,EAAM,OAAS,WACN,CAACsO,EAEV,UAAWM,MAAWpD,EAAO6C,CAAI,EAAG,CAClC,GAAIO,KAAYL,EACd,SAGF,MAAMM,GAASrD,EAAO6C,CAAI,EAAEO,EAAO,EAC7B,CAAE,KAAME,GAAO,OAAAC,EAAO,EAAIF,GAEhC,GAAI,CAACE,IAAUD,OAAS,OAAWJ,GAAMI,EAAK,EAAG,CAC/CH,GAAkB,GAClB3O,EAAM,OAAS,GACf,KACF,CACF,CAGFsO,EAAQ,GAER,CAACK,IAAmB,EAAE,IAAI,SAASzM,GAAM6K,GAAGC,EAAC,CAC/C,CACF,CACF,CAEA,EAAE,IAAI,QAAQ,CAChB,EAEA,IAAIN,GAAoC,KAExC,SAASsC,GAASC,EAAqBC,EAAiC,CACtE,OAAAxC,GAAgB,QACT,MAAiBuC,EAAO,CAAC,EAAGC,EAAgB,CAAC,CAAE,OAAAC,CAAO,IAAM,CACjEzC,GAAgByC,CAClB,CAAC,CACH,CAEA,MAAO,CACL,OAAA9B,GAEA,OAAAvD,GACA,QAAAJ,GACA,QAAAZ,GACA,QAAAE,GAEA,YAAAgD,GAGA,KAAAmB,GACA,UAAAS,GACA,KAAAM,GACA,SAAAc,EACF,CACF,CCtlBO,MAAMI,GAAmC,CAC9C,UAAW,EACX,SAAU,IACV,cAAe,GACf,WAAY,GACZ,YAAa,KAAsB,KACnC,UAAW,KAAsB,KACjC,SAAU,KAAoB,KAC9B,mBAAoB,EACpB,kBAAmB,CACrB,EAsBaC,GAA2C,CACtD,YAAa,GACb,aAAc,KAAyB,KACvC,UAAW,CACb,EClDO,SAASC,GACdL,EACA/J,EACAqK,EACA/O,EACAgP,EACAC,EACW,CAEX,GAAIR,EAAO,SAAW,GAAKA,EAAO,MAAOS,GAAOA,EAAG,SAAW,CAAC,EAC7D,MAAO,CACL,KAAM,GACN,OAAQ,CAAC,EACT,MAAO,CAAC,CACV,KAGF,OAAuBT,CAAM,KAC7B,OAAsBA,EAAQ/J,CAAW,EAEzC,IAAI7B,EAA+B,CAAE,GAAG4L,EAAO,CAAC,CAAE,EAIlD,MAAMU,EAAetM,EAAM,OAAO,UAAWuM,GAAMA,EAAE,OAAS,KAAU,IAAI,EAExED,GAAgB,GAAKV,EAAO,OAAS,IACvC5L,KAAQ,OAAoB,CAAE,OAAA4L,EAAQ,iBAAkB,EAAK,CAAC,GAAK5L,GAGrE,MAAMwM,GAEJxM,EAAM,OAAO,KAAMC,GAAUA,EAAM,OAAO,cAAgBkM,GAAclM,EAAM,OAASkM,CAAU,GACjGnM,EAAM,OAAO,KAAMC,GAAUA,EAAM,OAAS,KAAU,MAAM,GAC5DD,EAAM,OAAOsM,CAAY,EAE3B,GAAIE,IAAU,KAAM,CAClB,MAAMC,EAAkB,CAACD,EAAM,EACzBE,GAAiB,CAAC,EAElB/K,GACJyK,GAAkB,KACd,OACApM,EAAM,OAAO,KAEVC,GAAUA,EAAM,OAAO,cAAgBmM,GAAkBnM,EAAM,OAASmM,CAC3E,EAENpM,EAAM,OAAO,QAASC,GAAU,CAC9B,GAAIA,IAAUuM,GACZ,GAAIvM,EAAM,OAAS,KAAU,QAAU,CAACA,EAAM,OAAO,QAAQ,UAAU,IAAK,CAC1E,MAAM0M,GAAS,CACb,GAAG1M,EACH,OAAQA,EAAM,OAAO,IAAKyF,IAAO,OAAO,SAASA,EAAC,EAAIA,GAAI,IAAK,EAE/D,OAAQ,CACN,GAAGzF,EAAM,OACT,OAAQ,CACN,GAAGA,EAAM,OAAO,OAChB,SAAU,CACR,MAAO,IACP,KAAMiM,CACR,CACF,CACF,CACF,EAEAO,EAAO,KAAKE,EAAM,CACpB,MACED,GAAM,KAAKzM,CAAK,CAGtB,CAAC,EAED,IAAI2M,GAAsB,KAEtBH,EAAO,SAAW,IACpBG,MAAO,KAAE,iCAAkC,yBAAyB,GAGtE5M,EAAM,OAASyM,EAEf,MAAMI,EAAS,CAAC7M,CAAK,EAErB,gBAAsB6M,EAAQ1P,EAAO,CAAC,EAE/B,CACL,OAAA0P,EACA,MAAAH,GACA,MAAO/K,GACP,KAAAiL,EACF,CACF,CAEA,MAAO,CACL,OAAQ,CAAC,EACT,MAAO,CAAC,EACR,MAAO,KACP,QAAM,KAAE,gCAAiC,2CAA2C,CACtF,CACF,CAYO,MAAME,GAAa,CAAC,CAAE,OAAAD,EAAQ,YAAAE,EAAa,MAAAlQ,EAAO,YAAAmQ,EAAa,QAAAC,EAAS,SAAAnI,EAAU,MAAA3H,CAAM,IAAsB,CACnH,GAAI,CACF,UAAAwH,EACA,WAAAQ,GACA,SAAAC,EACA,UAAAC,GAAY,EACZ,SAAA6G,GACA,KAAArN,GACA,QAAAqO,EACA,mBAAAC,EACA,oBAAAC,GACA,kBAAAC,GAAoB,EACpB,OAAAC,GACA,cAAAC,EACF,EAAIN,EAEAjN,EAAQ6M,EAAO,CAAC,EAEpB,MAAMW,EAAU,IAAIC,EAAA,EAEdC,GAAa1N,EAAM,OAAO,IAAI,CAACuM,EAAGrP,IAClCgP,KAAa,KAAa,WACrB,MAAoB,CACzB,MAAO,CACL,GAAGK,EACH,OAAQ,CACN,GAAGA,EAAE,OACL,KAAM,aACR,CACF,EACA,MAAApP,CACF,CAAC,EAGIoP,EAAE,OACV,EAEK/H,GAAc,CAACkE,EAAmB9L,OAC/B,OAAuB8Q,GAAWhF,CAAS,EAAE9L,CAAK,CAAC,EAGtD6H,GAAmB,CAACiE,EAAmB9L,IACpC+Q,GAAanJ,GAAYkE,EAAW9L,CAAK,EAAGwQ,EAAmB,EAIlEQ,GAAiBC,GAAoBb,CAAW,EAGlDhN,EAAM,OAAO,SAAW,GAAKkM,KAAa,KAAa,OACrDa,IAAgB,IAClB5H,GAAaC,GAGfA,EAAW,GAGb,MAAMd,GAAW,CAACoE,EAAmBgC,IAC5B1K,EAAM,OAAO0I,CAAS,EAAE,OAAOgC,CAAQ,EAIhD,IAAInG,GAEAG,GAAc,EAElB,GAAI7H,GAAS,KAAM,CACjB,MAAMiR,EAAOjR,EAAM,QACnB6H,IAAe7H,EAAM,OAAO,OAAO,aAAe,KAAO,IAEzD0H,GAAW,CAACmE,EAAmBgC,IAAqBoD,EAAKjR,EAAO,OAAO6N,CAAQ,CAAC,EAAE,KACpF,MACyB1K,EAAM,OAAO,KAAMuM,GACjBA,EAAE,OAAO,OAAO,OAAS,KAAiB,YAI/DA,EAAE,OAAO,UAAU,KAAMwB,GAEnBA,EAAE,OAAS,QAEN,OAAO,OAAOA,EAAE,OAAO,EAAE,KAAMC,IAAWA,GAAO,OAAS,IAAI,EAEhED,EAAE,QAAQ,OAAO,OAAS,IAClC,CAEJ,IAMCrJ,IAFmB1E,EAAM,OAAO,KAAMuM,GAAMA,EAAE,OAAS,KAAU,MAAM,GAE1C,QAAQ,QAAQ,aAAe,KAAO,IAEnEhI,GAAW,CAACmE,EAAmBgC,IAAqB,CAClD,IAAIzK,GAAQD,EAAM,OAAO0I,CAAS,EAClC,OAAOzI,GAAM,QAASA,GAAM,OAAOyK,CAAQ,CAAC,EAAE,KAChD,GAIJ,MAAMvG,GAAoB,CACxB,KAAMyJ,GAAe,KACrB,KAAMA,GAAe,KACrB,WAAAzI,GACA,SAAAC,EACA,UAAAC,GACA,SAAA6G,GACA,SAAA5H,GACA,SAAAC,GACA,YAAAG,GACA,YAAAF,GACA,iBAAAC,GACA,SAAAK,EACA,KAAAjG,GACA,UAAA8F,EACA,OAAA2I,GACA,SAAUD,GACV,UAAWrN,EAAM,OAAO,CAAC,GAAG,OAAS,KAAU,MAAQ,CAACA,EAAM,OAAO,CAAC,EAAE,OAAO,MAAM,WAAW,OAAO,EACvG,KAAMA,EAAM,OAAO,IAAKuM,GAAMA,EAAE,OAAO,QAAQ,YAAc,KAAe,SAAS,EACrF,cAAAgB,GACA,WAAYL,EAAQ,OAAS,KAAmB,KAClD,EAEM7M,GAAS6D,GAAUC,GAAMhH,CAAK,EAQpC,GANAqQ,EAAQ,UAAUnN,GAAO,MAAM,EAE/BmN,EAAQ,QAAQ,OAAQnN,GAAO,IAAI,EACnCmN,EAAQ,QAAQ,YAAanN,GAAO,SAAS,EAC7CmN,EAAQ,QAAQ,OAAQnN,GAAO,IAAI,EAE/B8M,IAAuB,EAAG,CAG5B,IAAIc,EAAW,GACXC,EAAWN,GAAe,OAAS,KAAiB,WAAa,GAAK,EAE1EJ,EAAQ,WAAWW,GAAmBnO,EAAOmN,EAAoBC,GAAqBa,EAAUC,CAAQ,CAAC,CAC3G,CAEAV,EAAQ,YAAYnN,GAAO,QAAQ,EAEnCmN,EAAQ,SAAS,CACf,SAAU,IACV,OAAQ,GACR,MAAOnN,GAAO,OACd,aAAc,KAAkB,QAChC,YAAauN,GAAe,KAC5B,UAAWA,GAAe,IAC5B,CAAC,EAED,MAAMQ,GACJpO,EAAM,OAAO,CAAC,GAAG,OAAO,QAAQ,gBAAkB,KAAc,OAC5D4N,GAAe,OAAS,KAAiB,WACvC,KAAc,OACd,KAAc,KAChB,KAAc,OACdS,GAAiBrO,EAAM,OAAO,CAAC,GAAG,OAAO,QAAQ,gBAAkB,KAAc,OAEvFwN,EAAQ,QAAQ,CACd,SAAU,IACV,OAAQ,GACR,UAAWY,GACX,MAAOpO,EAAM,OAAO,CAAC,GAAG,OAAO,QAAQ,UACvC,OAAQK,GAAO,QACf,OAAQuN,GAAe,OAAS,EAAIvN,GAAO,QAAU,OACrD,OAAQA,GAAO,QACf,SAAAyE,EACA,KAAM,CAAE,KAAM,EAAM,EACpB,MAAO,CAAE,KAAM,EAAM,EACrB,IAAK,GACL,kBAAmB8I,GAAe,OAAS,EAAIT,EAAqB,GAAK,EACzE,MAAAhQ,EACA,KAAMkR,EACR,CAAC,EAMD,QAASnR,EAAI,EAAGA,EAAI8C,EAAM,OAAO,OAAQ9C,IAAK,CAC5C,MAAM+C,EAAQD,EAAM,OAAO9C,CAAC,EAItBoR,EAA4B,CAAE,GAAGtC,GAAoB,GAAG/L,EAAM,OAAO,MAAO,EAE5EsO,EAAWtO,EAAM,OAAO,MAAQ,KAChC6B,MAAY,OAA0B7B,CAAK,EAE3CuO,MADa,OAAoBvO,EAAO9C,CAAK,EACpB,MAG/B,IAAIsR,GAAUH,EAAa,YACvBI,GAAUJ,EAAa,YAuE3B,GArEIG,IAAW,MAAQxO,EAAM,OAAO,KAAO,OACzCwO,GAAU,GAGRC,IAAW,MAAQzO,EAAM,OAAO,KAAO,OACzCyO,GAAU,GAIRJ,EAAa,iBAAmBrO,EAAM,OAAO,aACtBqO,EAAa,gBAAgB,MAAQ,KAAyB,OAC9D,KAAyB,KAChDd,EAAQ,cAAc,CACpB,OAAQc,EAAa,gBACrB,WAAYrO,EAAM,OAAO,WACzB,SAAAsO,EACA,MAAApR,EACA,QAAS8C,EAAM,OAAO,IACtB,QAASA,EAAM,OAAO,IACtB,QAASqO,EAAa,YACtB,QAASA,EAAa,WACxB,CAAC,EAILd,EAAQ,UAAU,CAChB,SAAAe,EACA,QAAS,GACT,UAAWD,EAAa,UACxB,UAAWE,GACX,YAAaF,EAAa,YAC1B,MAAAnR,EACA,UAAA2E,GACA,YAAazB,GAAO,YACpB,KAAM,CAACiO,EAAa,UAAU,IAC9B,aAAcA,EAAa,aAC3B,WAAYrO,EAAM,OAAO,WACzB,QAASA,EAAM,OAAO,IACtB,QAASA,EAAM,OAAO,IACtB,QAASqO,EAAa,YACtB,QAASA,EAAa,WAYxB,CAAC,EAGDd,EAAQ,SAAS,CACf,SAAAe,EACA,IAAKtO,EAAM,OAAO,IAClB,IAAKA,EAAM,OAAO,IAClB,QAAAwO,GACA,QAAAC,GACA,aAAcJ,EAAa,iBAC3B,YAAaV,GAAe,KAC5B,UAAWA,GAAe,KAC1B,aAAcU,EAAa,mBAAmB,KAC9C,IAAKA,EAAa,mBAAmB,IACrC,SAAUrO,EAAM,OAAO,QACzB,CAAC,EAEGqO,EAAa,gBAAkB,KAAc,OAAQ,CACvD,IAAI9M,GAAY8M,EAAa,eACzB,CAAC9M,IAAaA,KAAc,KAAc,QAC5CA,GAAY,KAAc,MAExBoM,GAAe,OAAS,IACtBpM,KAAc,KAAc,OAC9BA,GAAY,KAAc,QAExBA,KAAc,KAAc,QAC9BA,GAAY,KAAc,MAI9B,IAAImN,GAAsB,CACxB,SAAAJ,EACA,MAAOD,EAAa,UACpB,KAAMA,EAAa,UACnB,UAAA9M,GACA,YAAa,CAACkE,GAAGkJ,QAAa,OAAuB3O,EAAM,QAASyF,GAAGkJ,EAAQ,CAAC,EAChF,OAAQhB,GAAe,OAAS,EAAIvN,GAAO,QAAU,OACrD,kBAAmBuN,GAAe,OAAS,EAAIT,EAAqB,GAAK,EACzE,MAAAhQ,EACA,KAAM,CAAE,KAAMmR,EAAa,YAAa,EACxC,SAAUrO,EAAM,OAAO,QACzB,EAEIqO,EAAa,iBACfK,GAAS,OAAS,CAChB,KAAM,EACR,GAGEL,EAAa,gBAAkB,KAAc,SAC/CK,GAAS,MAAQH,IAGnBhB,EAAQ,QAAQmB,EAAQ,CAC1B,CACF,CAEA,IAAI9C,MAAiB,MAAkB7L,CAAK,EAE5C,OAAAwN,EAAQ,kBAAkB3B,EAAc,EAEjC,CACL,QAAA2B,EACA,SAAU,CAACqB,EAAsBC,KAC/BjC,EAASgC,EACT7O,EAAQ6M,EAAO,CAAC,EAChBhQ,EAAQiS,EAEDtB,EAAQ,SAAUX,CAAM,EAEnC,CACF,EAEA,SAASc,GAAa/Q,EAAemS,EAAgB,CACnD,OAAInS,EAAM,OAASmS,EACVnS,EAAM,UAAU,EAAGmS,CAAM,EAAE,OAAO,KAAK,EAEvCnS,CAEX,CAEA,SAASuR,GACPnO,EACAgP,EACAC,EACAhB,EAAW,EACXC,EAAW,EACF,CACT,MAAMgB,EAASlP,EAAM,OAAO,CAAC,EAAE,OACzBoI,EAAW,KACX+G,EAAmBnP,EAAM,OAAO,CAAC,EAAE,QACnCoP,GAAqBlS,GAClBiS,EAAmBA,EAAiBD,EAAOhS,CAAC,CAAC,EAAIgS,EAAOhS,CAAC,EAElE,IAAImS,EAAY,EAChB,QAASnS,EAAI,EAAGA,EAAIgS,EAAO,OAAQhS,IAAK,CACtC,IAAIoS,KAAOxL,EAAA,IAAY6J,MAAa,OAAuByB,GAAkBlS,CAAC,CAAC,EAAG+R,CAAc,EAAG7G,CAAQ,EAC3GiH,EAAYC,EAAK,MAAQD,EAAYC,EAAK,MAAQD,CACpD,CAGA,MAAME,GACJP,EAAc,EACV,KAAK,IAAKA,EAAc,KAAK,GAAM,GAAG,KACtClL,EAAA,IACE6J,MAAa,OAAuByB,GAAkBF,EAAO,OAAS,CAAC,CAAC,EAAGD,CAAc,EACzF7G,CACF,EAAE,MACF,EAGAoH,GACJR,EAAc,EACV,KAAK,IAAKA,EAAc,GAAK,KAAK,GAAM,GAAG,KAC3ClL,EAAA,IAAY6J,MAAa,OAAuByB,GAAkB,CAAC,CAAC,EAAGH,CAAc,EAAG7G,CAAQ,EAAE,MAClG,EAGAqH,GACJ,KAAK,KAAMT,GAAe,EAAIA,EAAcA,EAAc,IAAM,KAAK,GAAM,GAAG,EAAIK,EAAYnB,EAEhG,MAAO,CACL,KAAK,MAAM,KAAuB,IAAM,OAAO,EAC/CqB,GACAE,GACA,KAAK,IAAI,EAAGD,GAAcvB,CAAQ,CACpC,CACF,CAEA,SAASJ,GAAoBb,EAA6B,CACxD,OAAIA,IAAgB,KAAe,SAC1B,CACL,KAAM,KAAiB,WACvB,KAAM,KAAe,MACrB,KAAM,KAAiB,SACvB,KAAM,KAAe,EACvB,EAGK,CACL,KAAM,KAAiB,SACvB,KAAM,KAAe,KACrB,KAAM,KAAiB,WACvB,KAAM,KAAe,KACvB,CACF,CCxhBA,MAAM0C,MAAY5L,EAAA,IAAY,IAAK,IAAoB,EAAE,MACnD6L,GAAS,KAAK,GAAK,IAEZC,GAAiBC,GAA+B,CAC3D,KAAM,CAAE,KAAAxO,EAAM,QAAA4L,EAAS,YAAApL,EAAa,MAAA4B,EAAO,OAAAC,EAAQ,SAAAoB,EAAU,GAAAgL,EAAI,iBAAA3P,EAAiB,EAAI0P,EAKhF1S,KAAQ,MAAU,EAElB,CACJ,SAAAiI,GACA,UAAAC,GAAY,EACZ,UAAAV,GACA,WAAAQ,EACA,SAAA+G,EACA,OAAAoB,GACA,QAAAJ,GACA,KAAArO,GACA,mBAAAsO,GACA,kBAAAE,EACA,cAAAE,EACA,OAAAf,GACA,aAAAuD,EACF,EAAI9C,EAGJ,GAAI,CAAE,YAAAD,GAAa,oBAAAI,GAAsB,CAAE,EAAIH,EAE/CD,GACEA,KAAgB,KAAe,KAC3BvJ,EAAQC,EACN,KAAe,WACf,KAAe,SACjBsJ,GAINI,GACED,KAAuB,EACnB,IACAC,IAEA,KAAK,MAAM1J,EAAS,EAAI,KAAK,IAAI,KAAK,IAAIyJ,GAAqBwC,EAAM,CAAC,EAAID,GAAY,CAAC,EAG7F,MAAMM,MAAO,WACX,IAAM/D,GAAW5K,EAAK,OAAQQ,EAAaqK,EAAU/O,EAAOqP,GAAQuD,EAAY,EAChF,CAAC1O,EAAK,OAAQQ,EAAaqK,EAAU/O,EAAOqP,GAAQuD,EAAY,CAClE,EAEME,MAAY,WAChB,IACED,GAAK,OAAO,IAAKhQ,IAAW,CAC1B,GAAGA,EACH,OAAQA,EAAM,OAAO,OAAO,CAACC,EAAO/C,IAAMA,IAAM,GAAK,CAAC+C,EAAM,OAAO,UAAU,GAAG,CAClF,EAAE,EACJ,CAAC+P,GAAK,MAAM,CACd,EAEME,GAAeD,GAAU,CAAC,GAAG,QAAU,EACvCE,GAAcF,GAAU,CAAC,GAAG,OAAO,QAAU,EAC7ClD,GAAc,KAAK,IAAI,GAAIiD,GAAK,OAAO,CAAC,GAAG,OAAO,QAAU,GAAK,CAAC,EAExE,GAAI,CAAE,QAAAxC,GAAS,SAAA7B,EAAS,KAAI,WAC1B,IACSuE,KAAiB,EACpB,CAAE,QAAS,KAAM,SAAU,IAAK,EAChCpD,GAAW,CAAE,OAAQmD,GAAW,YAAAlD,GAAa,MAAOiD,GAAK,MAAO,YAAAhD,GAAa,QAAAC,EAAS,SAAAnI,EAAU,MAAA3H,CAAM,CAAC,EAG7G,CACE6P,GACAlI,EACA+K,EAAM,KAAK,aAEX9C,GACAoD,GACAD,GAEA9K,GACAC,GACAV,GACAQ,EACA+G,EACAoB,GACAJ,GACArO,IAAM,UACNsO,GACAE,EACAE,EACAf,GACAuD,GACA3C,EAEF,CACF,EAEA,MAAMgD,MAAW,WACf,IAAOzE,IAAY,KAAO,CAAC,EAAIA,GAASsE,GAAWD,GAAK,KAAK,EAC7D,CAACrE,GAAUsE,GAAWD,GAAK,KAAK,CAClC,EAEA,GAAIA,GAAK,MAAQ,MAAQxC,IAAW,KAClC,SACE,OAAC6C,EAAA,GACC,QAASP,EACT,YAAAjO,EACA,KAAAR,EACA,QAAS2O,GAAK,MAAQ,GACtB,iBAAkB,GACpB,EAIJ,MAAMM,EACJhD,GAAO,YAAchM,GAAuBkM,GAASwC,GAAK,MAAO,KAC/D,OAACzO,GAAc,CAAC,KAAMyO,GAAK,OAAS,WAAYA,GAAK,MAAQ,GAAG1C,EAAA,CAAQ,EACtE,KAEN,SACE,OAAC3K,EAAA,IACC,MAAOkN,EAAM,MACb,OAAQA,EAAM,OAEd,OAAQS,EAEP,UAACC,EAAUC,OACV,OAAC,IAAU,CAAC,OAAQhD,GAAU,KAAM4C,GAAU,MAAOG,EAAU,OAAQC,EACpE,SAAAX,EAAM,QAAQ,QAAQ,OAAS,KAAmB,SACjD,OAACY,EAAA,IACC,OAAQjD,GACR,SAAUP,EAAQ,QAAQ,SAC1B,UACEA,EAAQ,QAAQ,OAAS,KAAmB,OAAS,KAAiB,KAAO,KAAiB,KAEhG,aAAc,CAACvE,EAAWE,KACxBqH,GAAU,CAAC,EAAE,OAAOvH,CAAS,EAAE,WAAW,CAAE,cAAeE,EAAQ,CAAC,GAAK,CAAC,EAE5E,OAAQ,CAAC8H,EAAGC,GAAUjI,GAAWrM,GAAUuU,GAASC,GAAYC,GAAS5P,QAErE,OAAC6P,EAAA,GACC,OAAQd,GAAU,CAAC,EACnB,MAAOD,GAAK,MACZ,SAAAW,GACA,UAAAjI,GACA,KAAMuE,EAAQ,QAAQ,KACtB,UAAWA,EAAQ,QAAQ,KAC3B,SAAA5Q,GACA,UAAW4Q,EAAQ,QAAQ,UAC3B,iBAAA9M,GACA,UAAAe,GACA,UAAW+L,EAAQ,QAAQ,UAC7B,CAEJ,CACF,EAEJ,EAEJ,CAEJ,E,oDCrLO,MAAM+D,GAAqBnB,GAAuC,CACvE,MAAMoB,EAA+C,CACnD,CACE,SAAO,KAAE,uDAAwD,MAAM,EACvE,MAAO,EACP,eAAa,KAAE,6DAA8D,qBAAqB,CACpG,EACA,CACE,SAAO,KAAE,wDAAyD,OAAO,EACzE,MAAO,IACP,eAAa,KAAE,8DAA+D,8BAA+B,CAC3G,QAAS,OACX,CAAC,CACH,EACA,CACE,SAAO,KAAE,yDAA0D,QAAQ,EAC3E,MAAO,IACP,eAAa,KAAE,+DAAgE,8BAA+B,CAC5G,QAAS,OACX,CAAC,CACH,EACA,CACE,SAAO,KAAE,wDAAyD,OAAO,EACzE,MAAO,IACP,eAAa,KAAE,8DAA+D,8BAA+B,CAC3G,QAAS,OACX,CAAC,CACH,CACF,EACA,IAAIrU,EAAQiT,EAAM,OAAS,EAC3B,MAAMqB,EAAQtU,EAAQ,EAClBsU,IACFtU,GAAS,IAEX,IAAIuU,EAAMF,EAAa,CAAC,EACxB,UAAWvL,KAAKuL,EAEd,GADAE,EAAMzL,EACF9I,GAASuU,EAAI,MACf,MAIJ,MAAMC,EAAmBnI,GAAgB,CACvC4G,EAAM,SAAS5G,GAAOiI,EAAQ,GAAK,EAAE,CACvC,EAEMG,EAAc,IAAM,CACxBxB,EAAM,SAASA,EAAM,MAAQ,EAAE,CACjC,EAEA,SACE,QAAC,MAAe,CACd,oBAACyB,GAAA,EAAgB,CAAC,MAAOH,EAAI,MAAO,QAASF,EAAc,SAAUG,CAAA,CAAiB,EACrFxU,IAAU,MACT,OAACyC,GAAA,GACC,WAAS,KACP,yEACA,mCACF,EACA,UAAU,MAEV,mBAAC,OACC,mBAACkS,GAAA,EAAQ,CAAC,MAAOL,EAAO,SAAUG,EAAa,SAAO,KAAE,yCAA0C,KAAK,EAAG,EAC5G,EACF,GAEJ,CAEJ,E,4BClEO,MAAMG,GAAiE,CAACC,EAAOC,EAAcC,IAAgB,CAClH,GAAID,IAAiB,QAAS,CAC5B,MAAME,EAA6BD,EAAY,QAEzC9P,EAAc4P,EAAM,aAAe,CAAE,SAAU,CAAC,EAAG,UAAW,CAAC,CAAE,EAEvE,GAAIG,EAAa,OAAO,OAAS,SAAU,CACzC,MAAMC,EAAkBJ,EAAM,iBAAmB,CAAC,EAClDI,EAAgB,KACd,CACE,GAAI,SACJ,QAAS,CACP,SAAUC,GAAWF,EAAa,OAAO,MAAM,CACjD,CACF,EACA,CACE,GAAI,YACJ,QAAS,CAAC,CACZ,CACF,EAEAH,EAAM,gBAAkBI,EAGxBhQ,EAAY,UAAU,KAAK,CACzB,QAAS,CACP,GAAI,MAAe,OACnB,QAAS,OACX,EACA,WAAY,CACV,CACE,GAAI,uBACJ,MAAO,KAAc,MACvB,CACF,CACF,CAAC,EAED4P,EAAM,YAAc5P,EACpB4P,EAAM,QAAU,CACd,GAAGA,EAAM,QACT,WAAY,CACd,CACF,CACF,CAEA,MAAO,CAAC,CACV,EAGMK,GAAcC,GAAmC,CACrD,MAAMC,EAA8B,CAAC,EAErC,OAAAD,GAAU,QAASE,GAAY,CAExB,OAAO,OAAO,KAAS,EAAE,SAASA,CAAoB,EASzDD,EAAkB,KAAKC,CAAO,EAR1BA,IAAY,UACdD,EAAkB,KAAK,MAAU,WAAW,EACnCC,IAAY,QACrBD,EAAkB,KAAK,MAAU,GAAG,EAC3BC,IAAY,OACrBD,EAAkB,KAAK,MAAU,IAAI,CAK3C,CAAC,EAEMD,EAAWC,EAAoB,CAAC,MAAU,GAAG,CACtD,E,gBCpEO,MAAME,EAA4B,CACvC,oBAAoB1E,EAA0C,CAC5D,OAAOA,EAAQ,gBAAsC,CACnD,KAAM,KAAe,SACrB,SAAU,WACV,QAAS,CACP,UAAW,KAAe,MAC1B,OAAQ,CACN,MAAO,CAAC,EACR,YAAa,KAAkB,KAC/B,WAAY,GACZ,UAAW,OACb,CACF,EACA,YAAa,CACX,SAAU,CACR,KAAM,QACN,OAAQ,CAAC,CACX,EACA,UAAW,CAAC,CACd,EACA,YAAa,CACX,gBAAkBhD,GAAM,CACtBA,EAAE,QAAS,SAAW,EACxB,CACF,CACF,CAAC,CACH,CAEA,sBAAsBgD,EAA0C,CAC9D,MAAM2E,EAAO,KAAK,oBAAoB3E,CAAO,EACvC,CAAE,YAAA4E,CAAY,EAAI5E,EAEpB4E,EAAY,aAAe,IAI3B,CAACA,EAAY,gBAAkB,CAACA,EAAY,gBAK5CA,EAAY,cAAgB,KAKhCD,EAAK,OAAO,CACV,KAAM,KAAe,QACvB,CAAC,EAEGC,EAAY,iBAAmB,IACjCD,EAAK,OAAO,CACV,KAAM,KAAe,gBACrB,QAAS,CACP,SAAU,KAAa,MACzB,CACF,CAAC,EACDA,EAAK,OAAO,CACV,KAAM,KAAe,uBACrB,QAAS,CACP,SAAU,KAAa,OACzB,CACF,CAAC,GAIHA,EAAK,OAAO,CACV,KAAM,KAAe,mBACrB,QAAS,CACP,YAAa,KAAe,UAC9B,CACF,CAAC,EAEGC,EAAY,iBAAmB,IACjCD,EAAK,OAAO,CACV,KAAM,KAAe,0BACrB,QAAS,CACP,SAAU,KAAa,OACvB,YAAa,KAAe,UAC9B,CACF,CAAC,EAEDA,EAAK,OAAO,CACV,KAAM,KAAe,iCACrB,QAAS,CACP,YAAa,KAAe,WAC5B,SAAU,KAAa,OACzB,CACF,CAAC,IAEL,CACF,CC5EO,MAAM,GAAS,IAAIE,EAAA,EAAkCzC,EAAa,EACtE,sBAAsB4B,EAAqC,EAC3D,eAAe,CACd,gBAAiB,CACf,CAAC,KAAoB,KAAK,EAAG,CAC3B,SAAU,CACR,eAAgB,GAChB,qBAAsB,EACxB,EACA,aAAc,CACZ,KAAM,IAAiB,cACzB,CACF,EACA,CAAC,KAAoB,KAAK,EAAG,CAC3B,SAAU,CACR,aAAc,EAChB,CACF,EACA,CAAC,KAAoB,OAAO,EAAG,CAC7B,iBAAkB,EACpB,CACF,EACA,gBAAkBhE,GAAY,CAC5B,MAAM8E,EAAMtG,GAEZwB,EACG,eAAe,CACd,KAAM,YACN,QAAM,KAAE,kCAAmC,YAAY,EACvD,aAAc8E,EAAI,UAClB,SAAU,CACR,IAAK,EACL,IAAK,GACL,KAAM,CACR,CACF,CAAC,EACA,eAAe,CACd,KAAM,cACN,QAAM,KAAE,oCAAqC,cAAc,EAC3D,aAAcA,EAAI,YAClB,SAAU,CACR,IAAK,EACL,IAAK,IACL,KAAM,CACR,CACF,CAAC,EACA,SAAS,CACR,KAAM,eACN,QAAM,KAAE,qCAAsC,eAAe,EAC7D,gBAAc,KAAqB,EAAE,aAAa,CAAC,EAAE,MACrD,SAAU,CACR,WAAS,KAAqB,EAAE,YAClC,CACF,CAAC,EAEH9E,EAAQ,UAAU,CAChB,SAAU,CAAC,cAAc,EACzB,QAAM,KAAE,iCAAkC,WAAW,EACrD,KAAM,YACN,SAAU,CACR,QAAS,CACP,CACE,SAAO,KAAE,mDAAoD,UAAU,EACvE,MAAO,KAAe,SACtB,eAAa,KACX,yDACA,kDACF,CACF,EACA,CACE,SAAO,KAAE,qDAAsD,YAAY,EAC3E,MAAO,KAAe,UACtB,eAAa,KACX,2DACA,mDACF,CACF,CACF,EACA,YAAa,EACf,EACA,iBAAkB,EACpB,CAAC,EAEDA,EAAQ,gBAAgB,CACtB,GAAI,kBACJ,KAAM,kBACN,QAAM,KAAE,uCAAwC,iBAAiB,EACjE,SAAU,IAAC,KAAE,sCAAuC,YAAY,CAAC,EACjE,aAAc,CAAE,KAAM,KAAyB,GAAI,EACnD,SAAU,CACR,WAAS,KAAqB,EAAE,sBAClC,EACA,OAAQ+E,GAAA,EACR,SAAUA,GAAA,EACV,QAAS,KACT,YAAa,IAAM,EACrB,CAAC,EAED,KAAmC/E,EAAS8E,CAAG,EAC/C,IAAiC9E,CAAO,CAC1C,CACF,CAAC,EACA,gBAAiBA,GAAY,CAC5BA,EACG,mBAAmB,CAClB,KAAM,SACN,QAAM,KAAE,8BAA+B,QAAQ,EAC/C,SAAU,CACR,mBAAiB,KAAE,qCAAsC,4BAA4B,CACvF,CACF,CAAC,EACA,SAAS,CACR,KAAM,cACN,QAAM,KAAE,mCAAoC,aAAa,EACzD,SAAU,CACR,QAAS,CACP,CAAE,MAAO,KAAe,KAAM,SAAO,KAAE,iDAAkD,MAAM,CAAE,EACjG,CACE,MAAO,KAAe,WACtB,SAAO,KAAE,uDAAwD,YAAY,CAC/E,EACA,CACE,MAAO,KAAe,SACtB,SAAO,KAAE,0DAA2D,UAAU,CAChF,CACF,CACF,EACA,aAAczB,GAAe,WAC/B,CAAC,EACA,eAAe,CACd,KAAM,qBACN,QAAM,KAAE,uCAAwC,2BAA2B,EAC3E,aAAcA,GAAe,mBAC7B,SAAU,CACR,IAAK,IACL,IAAK,GACL,KAAM,GACN,MAAO,CAAE,MAAO,UAAQ,MAAO,UAAQ,EAAG,QAAM,GAAI,SAAO,GAAI,QAAM,EACrE,SAAU,EACZ,CACF,CAAC,EACA,eAAe,CACd,KAAM,sBACN,QAAM,KAAE,0CAA2C,8BAA8B,EACjF,eAAa,KACX,iDACA,wDACF,EACA,SAAU,CACR,eAAa,KAAE,iDAAkD,MAAM,EACvE,IAAK,CACP,EACA,OAAS5H,GAASA,EAAK,qBAAuB,CAChD,CAAC,EACA,gBAAgB,CACf,GAAI,oBACJ,KAAM,oBACN,QAAM,KAAE,2CAA4C,+BAA+B,EACnF,aAAc4H,GAAe,kBAC7B,OAAQiF,EACV,CAAC,EACA,SAAS,CACR,KAAM,YACN,QAAM,KAAE,mCAAoC,aAAa,EACzD,SAAU,CACR,QAAS,CACP,CAAE,MAAO,KAAe,KAAM,SAAO,KAAE,iDAAkD,MAAM,CAAE,EACjG,CAAE,MAAO,KAAe,OAAQ,SAAO,KAAE,mDAAoD,QAAQ,CAAE,EACvG,CAAE,MAAO,KAAe,MAAO,SAAO,KAAE,kDAAmD,OAAO,CAAE,CACtG,CACF,EACA,aAAcjF,GAAe,SAC/B,CAAC,EACA,SAAS,CACR,KAAM,WACN,QAAM,KAAE,gCAAiC,UAAU,EACnD,SAAU,CACR,WAAS,KAAqB,EAAE,QAClC,EACA,aAAcA,GAAe,QAC/B,CAAC,EACA,eAAe,CACd,KAAM,aACN,QAAM,KAAE,mCAAoC,aAAa,EACzD,aAAcA,GAAe,WAC7B,SAAU,CACR,IAAK,EACL,IAAK,EACL,KAAM,GACR,EACA,OAAQ,CAACpB,EAAGtJ,IACNsJ,EAAE,UAAYA,EAAE,WAAa,KAAa,KACrC,GAEF6H,GAAkBnR,CAAI,IAAM,CAEvC,CAAC,EACA,eAAe,CACd,KAAM,WACN,QAAM,KAAE,iCAAkC,WAAW,EACrD,aAAc0K,GAAe,SAC7B,SAAU,CACR,IAAK,EACL,IAAK,EACL,KAAM,GACR,CACF,CAAC,EACA,eAAe,CACd,KAAM,YACN,QAAM,KAAE,kCAAmC,YAAY,EACvD,aAAcA,GAAe,UAC7B,SAAU,CACR,IAAK,EACL,IAAK,GACL,KAAM,GACR,CACF,CAAC,EACA,iBAAiB,CAChB,KAAM,gBACN,QAAM,KAAE,sCAAuC,8BAA8B,EAC7E,aAAcA,GAAe,cAC7B,OAASpB,GAAMA,EAAE,WAAa,KAAa,IAC7C,CAAC,EAEH6C,EAAQ,mBAAmB,CACzB,KAAM,eACN,QAAM,KAAE,sCAAuC,gBAAgB,EAC/D,eAAa,KACX,6CACA,kEACF,CACF,CAAC,EAED,IAAuCA,EAAS,GAAO,GAAO,GAAiB,EAC/E,KAAsCA,CAAO,EAC7C,KAAwCA,EAAS,EAAK,CACxD,CAAC,EACA,uBAAuB,IAAI0E,EAA6B,EAE3D,SAASM,GAAkBnR,EAA4B,CACrD,IAAIoR,EAAQ,EACZ,GAAIpR,EACF,UAAWrB,KAASqB,EAClB,UAAWpB,KAASD,EAAM,OACpBC,EAAM,OAAS,KAAU,QAC3BwS,IAKR,OAAOA,CACT,C,gECrQO,IAAKC,GAAAA,IACVA,EAAA,OAAS,SACTA,EAAA,KAAO,OACPA,EAAA,UAAY,YACZA,EAAA,MAAQ,QACRA,EAAA,MAAQ,QALEA,IAAAA,GAAA,IAQAC,GAAAA,IACVA,EAAA,OAAS,SACTA,EAAA,OAAS,SACTA,EAAA,MAAQ,QACRA,EAAA,IAAM,MACNA,EAAA,UAAY,YALFA,IAAAA,GAAA,IAuBAC,GAAAA,IACVA,EAAA,QAAU,UACVA,EAAA,MAAQ,QACRA,EAAA,KAAO,OACPA,EAAA,SAAW,WACXA,EAAA,KAAO,OALGA,IAAAA,GAAA,IAoBAC,GAAAA,IACVA,EAAA,IAAM,MACNA,EAAA,KAAO,OACPA,EAAA,IAAM,MAHIA,IAAAA,GAAA,IAWAC,GAAAA,IACVA,EAAA,SAAW,WADDA,IAAAA,GAAA,IAgBL,MAAMC,EAAqD,CAChE,SAAU,CAAC,CACb,EAgBaC,EAA6D,CACxE,YAAa,CAAC,CAChB,EAuCajH,EAAmC,CAC9C,YAAa,GACb,cAAe,GACf,QAAS,GACT,kBAAmB,EACrB,C,6DCvJO,MAAMkH,EAAe,CAAChT,EAAciT,IAAmB,CAC5D,MAAMC,EAAiC,CAAC,EAExC,IAAKlT,EAAM,OAAO,OAAO,QAAU,GAAK,GAAKA,EAAM,UAAY,KAAM,CACnE,MAAMyF,EAAIzF,EAAM,OAAOiT,CAAM,EACvBpF,EAAO7N,EAAM,QAAUA,EAAM,QAAQyF,CAAC,EAAI,CAAE,KAAM,GAAGA,CAAC,GAAI,QAAS,CAACA,CAAE,EAEtE0N,EAAa,IAAI,IAEvBnT,EAAM,SAAS,CAAE,gBAAiB6N,EAAM,cAAeoF,CAAO,CAAC,EAAE,QAASG,GAAS,CACjF,MAAMC,EAAM,GAAGD,EAAK,KAAK,IAAIA,EAAK,IAAI,GACjCD,EAAW,IAAIE,CAAG,IACrBH,EAAM,KAAKE,CAAI,EACfD,EAAW,IAAIE,CAAG,EAEtB,CAAC,CACH,CAEA,OAAOH,CACT,EAEaI,EAAsBC,GAAyB,CAAC,EAEhDC,EAAkB,CAC7BD,EACAvT,EACAyT,EACAC,IACG,CACH,MAAMvT,EAAqC,CAAC,EACtCwT,EAAe,IAAI,IAMzB,SAJqB,MAAWJ,EAAWvT,EAAOA,EAAM,MAAO,WAAayT,EAAazT,EAAM,OAAO,SAAW,CAAC,EAAG,CACnH,cAAe0T,CACjB,CAAC,EAEY,QAASlU,GAAW,CAC/B,MAAM6T,GAAM,GAAG7T,EAAO,KAAK,GACtBmU,EAAa,IAAIN,EAAG,IACvBlT,EAAQ,KAAKX,CAAM,EACnBmU,EAAa,IAAIN,EAAG,EAExB,CAAC,EAEMlT,CACT,C,2KCHO,MAAM2Q,GAAoB,CAAC,CAChC,OAAAlE,GACA,MAAAH,GACA,SAAAiE,EACA,UAAAjI,EACA,KAAAmL,EAAO,KAAmB,OAC1B,UAAAC,EAAY,KAAU,KACtB,SAAAzX,EACA,SAAA0X,EACA,UAAAxX,EACA,iBAAA4D,EAAoB6T,GAAQA,EAC5B,UAAA9S,EACA,UAAA+S,CACF,IAA8B,CAC5B,MAAMzH,EAASK,GAAO,OAAO,CAAC,EACxBqH,MAAO,MAAuB1H,EAAO,QAASA,EAAO,OAAOmE,EAAS,CAAC,CAAE,CAAC,CAAC,EAE1EwD,MAAe,MACnBtH,GAAO,OACPL,EACAmE,EACAjI,EACAmL,EACAC,EACC7T,GAAUA,EAAM,OAAS,KAAU,QAAUA,EAAM,OAAS,KAAU,KACvEgU,CACF,EAEAvH,IAAO,QAASzM,GAAU,CACnBA,EAAM,OAAO,QAAQ,UAAU,SAClCkU,GAAa,KAAK,CAChB,MAAOlU,EAAM,OAAO,aAAeA,EAAM,KACzC,SAAO,MAAIA,EAAOA,EAAM,OAAO0Q,EAAS,CAAC,CAAE,CAAC,CAC9C,CAAC,CAEL,CAAC,EAED,IAAIyD,GAEJ,GAAI1L,GAAa,KAAM,CACrB,MAAMzI,EAAQ4M,GAAO,OAAOnE,CAAS,EAC/B2L,GAAkBnT,EAAU,KAAMoT,IAAaA,GAAS,WAAa,EAAI,EAE/E,GAAIjY,GAAYgY,GAAiB,CAC/B,MAAMzL,GAAU+H,EAASjI,CAAS,EAC5BtI,KAAU,MAAgByM,GAAQ5M,EAAOE,EAAkByI,EAAO,EAExEwL,MAAS,OAAC,IAAgB,CAAC,UAAAlT,EAAsB,QAAAd,EAAkB,SAAA2T,CAAA,CAAoB,CACzF,CACF,CAEA,MAAMQ,EAAoC/H,EAAO,OAAO,QAAQ,UAAU,QACtE,KACA,CACE,MAAOA,EAAO,OAAS,KAAU,KAAO,GAAMA,EAAO,OAAO,aAAeA,EAAO,KAClF,MAAO0H,EACT,EAEJ,SACE,QAAC,IAAiB,CACf,UAAAK,GAAc,SAAQ,OAAC,IAAgB,CAAC,KAAMA,EAAY,SAAAlY,CAAA,CAAoB,KAC/E,OAAC,KACC,MAAO8X,GACP,SAAA9X,EACA,cAAY,MAAoB,CAAE,KAAAwX,EAAM,UAAAtX,CAAU,CAAC,EACnD,UAAAA,CAAA,CACF,EACC6X,EAAA,EACH,CAEJ,C,sKC7FA,SAASI,EAAa5I,EAAkC,CACtD,IAAI6I,EAAyC,IAAI,IA2CjD,OAzC2B7I,EAAO,IAAK5L,IAC9B,CACL,GAAGA,EACH,OAAQA,EAAM,OAAO,IAAKC,GAAU,CAClC,GAAIA,EAAM,OAAS,KAAU,KAAM,CACjC,IAAIsO,KAAW,KAActO,EAAM,OAAQA,EAAM,IAAI,EACjDyU,EAAWD,EAAc,IAAIlG,CAAQ,EAEpCmG,IACHA,EAAW,CAAC,EACZD,EAAc,IAAIlG,EAAUmG,CAAQ,GAGtC,IAAIC,EAAiB1U,EAAM,OAAO,QAAQ,EAAE,MAAM,EAC9C2U,EAAO3U,EAAM,OAAO,KAAM,KAAM,KAGpC,GAAIyU,EAAS,OAAS,EACpB,QAASxX,EAAI,EAAGA,EAAIyX,EAAK,OAAQzX,IAC/ByX,EAAKzX,CAAC,GAAKwX,EAAS,OAIxB,OAAAA,EAAS,KAAK,GAAGE,CAAI,EAGrB3U,EAAM,OAAO,KAAM,KAAM,KAAQyU,EAE1B,CACL,GAAGzU,EACH,OAAQ0U,CACV,CAGF,CAEA,OAAO1U,CACT,CAAC,CACH,EACD,CAGH,CAKO,SAAS4U,EACdhI,EACA1P,EACA2X,EAEAC,EACoB,CACpB,GAAI,CAAClI,GAAQ,OACX,OAAO,QAGT,MAAuBA,CAAM,EAE7B,IAAImI,EAAcD,GAAgB,KAG9BA,GAAgB,MAAQA,EAAe,IACzClI,EAAS,CACP,CACE,GAAGA,EAAO,CAAC,EACX,OAAQ,CAACA,EAAO,CAAC,EAAE,OAAOkI,CAAY,EAAG,GAAGlI,EAAO,CAAC,EAAE,OAAO,OAAO,CAACN,EAAGrP,IAAMA,IAAM6X,CAAY,CAAC,CACnG,CACF,GAMF,QAAS/U,KAAS6M,EAChB,QAAS5M,KAASD,EAAM,OAClBC,EAAM,OAAS,KAAU,MAAQ,OAAOA,EAAM,OAAO,CAAC,GAAM,WAC9DA,EAAM,UAAS,MAAiBA,EAAO,CAAE,gBAAiB,KAAU,IAAK,CAAC,EAAE,QAKlF,IAAIgV,EAAkB,EAEtBC,EAAO,QAASlV,KAAS6M,EACvB,QAAS5M,KAASD,EAAM,OACtB,GAAIC,EAAM,OAAS,KAAU,MAAQ,EAAEgV,EAAkB,EAAG,CAC1DpI,EAAS2H,EAAa3H,CAAM,EAC5B,MAAMqI,CACR,CAIJ,IAAIC,EAEJ,MAAMvJ,EAAsB,CAAC,EAE7B,QAAS5L,KAAS6M,EAAQ,CACxB,MAAMJ,EAAkB,CAAC,EAEzB,IAAI2I,EAAe,GACfC,GAAgB,GAEhBC,GAAcN,EACdhV,KACA,KAAyB,CACvB,MAAAA,EACA,kBAAmB8U,GAAW,KAAK,QAAQ,EAC3C,kBAAmBA,GAAW,GAAG,QAAQ,CAC3C,CAAC,EAEL,MAAMS,MAAc,KAAYD,EAAW,EAAE,OAE7C,QAASE,EAAW,EAAGA,GAAYD,IAAa,QAAU,GAAIC,IAAY,CACxE,MAAMvV,EAAQsV,GAAYC,CAAQ,EAElC,OAAQvV,EAAM,KAAM,CAClB,KAAK,KAAU,KACbmV,EAAe,GACf3I,EAAO,KAAKxM,CAAK,EACjB,MACF,KAAK,KAAU,OACboV,GAAgBL,EAAcQ,EAAW,EAAI,GAC7CL,EAAO,CACL,GAAGlV,EACH,OAAQA,EAAM,OAAO,IAAKyF,GAClB,OAAO,SAASA,CAAC,GAAKA,GAAK,KAG1BA,EAFE,IAGV,CACH,EAEA+G,EAAO,KAAK0I,CAAI,EAChB,MACF,KAAK,KAAU,KACbE,GAAgB,GAClB,KAAK,KAAU,OACbF,EAAO,CACL,GAAGlV,EACH,OAAQA,EAAM,MAChB,EAEAwM,EAAO,KAAK0I,CAAI,EAChB,MACF,KAAK,KAAU,QACbE,GAAgB,GAChB,MAAMI,GAA2BxV,EAAM,QAAQ,QAAU,CAAC,EACpDI,GAAS,CACb,GAAGJ,EAAM,OACT,IAAK,EACL,IAAK,EACL,OAAAwV,EACF,EAGIA,GAAO,oBAAsB,KAAkB,aACjDA,GAAO,kBAAoB,KAAkB,WAG/CN,EAAO,CACL,GAAGlV,EACH,OAAAI,GACA,KAAM,KAAU,OAChB,OAAQJ,EAAM,OAAO,IAAKyF,GACpBA,GAAK,KACAA,EAEMA,EAAK,EAAI,CACzB,CACH,KAEK,MAAcrF,GAAO,IAAI,IAC5BA,GAAO,KAAO,OACd8U,EAAK,WAAU,KAAoB,CAAE,MAAOA,EAAM,MAAAhY,CAAM,CAAC,GAG3DsP,EAAO,KAAK0I,CAAI,EAChB,KACJ,CACF,EAEKH,GAAeI,IAAiBC,IACnCzJ,EAAO,KAAK,CACV,GAAG5L,EACH,OAAQsV,GAAY,OACpB,OAAA7I,CACF,CAAC,CAEL,CAEA,OAAIb,EAAO,QACT8J,GAAsB9J,EAAQzO,EAAO,CAAC,EACtCwY,EAA4B/J,EAAQzO,CAAK,EAClCyO,GAGF,IACT,CAEA,MAAM+J,EAA8B,CAAC/J,EAAqBzO,IAAyB,CACjF,KAAM,CAAE,QAAAyY,CAAQ,EAAIzY,EAAM,cAC1B,UAAW6C,KAAS4L,EAClB,UAAW3L,KAASD,EAAM,OACxB,GAAIC,EAAM,OAAS,KAAU,KAAM,CACjC,MAAM4V,EAAaD,EAAQ3V,EAAM,OAAO,YAAe2V,EAAQ,MAAM,EAC/DE,EAAW3Y,EAAM,cAAc,eAAe0Y,CAAU,EACxDE,EAAa9V,EAAM,OAAO,KAAM,KAEtC8V,EAAW,MAAQ,MAAMA,EAAW,KAAM,MAAM,EAAE,KAAKD,CAAQ,EAC/D7V,EAAM,WAAU,KAAoB,CAAE,MAAAA,EAAO,MAAA9C,CAAM,CAAC,CACtD,CAGN,EAEauY,GAAwB,CAAC9J,EAAqBzO,EAAsB6Y,IAA0B,CACzG,IAAIC,EAAc,EAClBrK,EAAO,QAAS5L,GAAU,CACxBA,EAAM,OAAO,QAAQ,CAACC,EAAOuV,IAAa,CAEtCA,IAAaQ,IACZ/V,EAAM,OAAS,KAAU,QAAUA,EAAM,OAAS,KAAU,SAAWA,EAAM,OAAS,KAAU,QAEjGA,EAAM,MAAQ,CACZ,GAAGA,EAAM,MACT,YAAagW,GACf,EACAhW,EAAM,WAAU,KAAoB,CAAE,MAAAA,EAAO,MAAA9C,CAAM,CAAC,EAExD,CAAC,CACH,CAAC,CACH,EAEO,SAAS+Y,GAAaC,EAAiCC,EAAmC,CAC/F,MAAI,CAACD,GAAa,CAACA,EAAU,OACpB,CAACC,CAAe,EAElBD,EAAU,IAAKzQ,GAAOA,GAAG,OAASA,EAAI0Q,CAAgB,CAC/D,CAEO,MAAMC,GAAuBC,GAC3BA,EAAe,OAAS,KAAmB,OAASA,EAAe,WAAa,I,gEChQlF,IAAKC,GAAAA,IACVA,EAAA,OAAS,SACTA,EAAA,OAAS,SAFCA,IAAAA,GAAA,IAKAC,GAAAA,IACVA,EAAA,KAAO,OACPA,EAAA,OAAS,SAFCA,IAAAA,GAAA,IAKAC,GAAAA,IACVA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,eAAiB,eAHPA,IAAAA,GAAA,IAsBL,MAAMC,EAA+C,CAC1D,GAAI,EACN,EAgBa1K,EAA2C,CACtD,YAAa,GACb,KAAM,QACR,EA4BaD,EAAmC,CAC9C,OAAQ,CAAC,CACX,C,6JC1EO,SAAS4K,EAAI1W,EAAcgJ,EAAqB,CACrD,OAAIhJ,EAAM,WACD,MAAuBA,EAAM,QAAQgJ,CAAG,CAAC,EAG3C,GAAGA,CAAG,EACf,CAGA,SAAS2N,EAAiBvW,EAAuB,CAC/C,OAAIA,EAAO,KAAO,KAAe,QACxB,CAACL,EAAkB6W,IAAkBA,IAAUxW,EAAO,QAGxD,IAAM,EACf,CAEO,SAAS4L,EACd1J,EACAuU,EACAlL,EACA/J,EACA,IACA,MAAuB+J,CAAM,KAC7B,MAAsBA,EAAQ/J,CAAW,EAEzC,IAAIgL,EAAqB,CAAC,EAEtBiK,EAAa,SAAW,IAC1BA,EAAe,CAAC,CAAC,CAAC,GAGpB,KAAM,CAAE,QAAAlB,EAAS,eAAAmB,CAAe,EAAI,IAAO,OAAO,cAiLlD,GA/KAD,EAAa,QAAQ,CAACE,EAAWtO,IAAc,CAC7C,GAAInG,IAAY,KAAc,SACxByU,EAAU,OAAO,SAAW,MAAQA,EAAU,GAAG,SAAW,MAAQA,EAAU,GAAG,SAAW,MAC9F,OAIJ,IAAIC,KAAW,MACbD,EAAU,GAAG,SAAW,CACtB,GAAI,KAAe,QACnB,QAAS,IAAI,IAAI,CAAC,SAAU,MAAM,CAAC,CACrC,CACF,EACIE,KAAW,MACbF,EAAU,GAAG,SAAW,CACtB,GAAI,KAAe,OACnB,QAAS,QACX,CACF,EACIG,GAAeH,EAAU,SAAQ,MAAgBA,EAAU,MAAM,OAAO,EAAI,KAC5EI,GAAcJ,EAAU,QAAO,MAAgBA,EAAU,KAAK,OAAO,EAAI,KAEzEK,GAAeL,EAAU,MAAQJ,EAAiBI,EAAU,MAAM,OAAO,EAAI,KAGjFpL,EAAO,QAAQ,CAAC5L,EAAOsX,IAAa,CAElC,GAAID,IAAgB,MAAQ,CAACA,GAAarX,EAAOsX,CAAQ,EACvD,OAIF,IAAIC,GAAsB,CAAC,EAEvBC,GAA0B,CAAC,EAE3BC,EAAoBzX,EAAM,OAAO,OAClCC,GAAUA,EAAM,OAAS,KAAU,QAAUA,EAAM,OAAS,KAAU,IACzE,EAGIyJ,GAAI+N,EAAkB,KAAMxX,GAAUgX,EAAShX,EAAOD,EAAO4L,CAAM,CAAC,EAGpE8L,GAAgBD,EAAkB,OAAQxX,GAAUA,EAAM,OAAS,KAAU,MAAM,EAEnFpD,GACFsa,IAAgB,KACZO,GAAc,KAAMzX,GAAUA,IAAUyJ,IAAKyN,GAAclX,EAAOD,EAAO4L,CAAM,CAAC,EAChF,OACF0D,GACF8H,IAAe,KACXM,GAAc,KAAMzX,GAAUA,IAAUyJ,IAAKzJ,IAAUpD,IAASua,GAAanX,EAAOD,EAAO4L,CAAM,CAAC,EAClG,OAGFlC,IAAK,OAEPgO,GAAc,QAASzX,GAAU,CAC/B,GAAIA,IAAUyJ,IAKV,EAAAnH,IAAY,KAAc,OAAStC,IAAUpD,IAASoD,IAAUqP,MAKhE,EAAA/M,IAAY,KAAc,QAAUiV,GAAY,OAAS,IAKzDN,EAASjX,EAAOD,EAAO4L,CAAM,GAAK,CAAC3L,EAAM,OAAO,QAAQ,UAAU,IAAK,CACzE,IAAI0J,EAAI1J,EAEJH,GAAOkX,EAAU,MAAM,MAE3B,GAAIlX,IAAQ,KAAM,CAGhB,MAAM6X,GACJ/L,EAAO,OAAS,IAAM5L,EAAM,MAAQ,MAAQ,OAAO,KAAK2J,EAAE,QAAU,CAAC,CAAC,EAAE,OAAS,GAK7E,CAAE,YAAAiO,GAAa,kBAAAC,EAAkB,EAAIlO,EAAE,OACvCmO,GAAkBF,IAAe,MAAQC,IAAqB,KAEpE,GAAIF,IAAwBG,GAAiB,CAE3C,MAAMC,GAAmBpO,EAAE,MAAO,YAGlCA,EAAE,OAAO,YAAcA,EAAE,OAAO,kBAAoBA,EAAE,MAAO,YAAc,OAE3E7J,MAAO,MAAoB6J,EAAG3J,EAAO4L,CAAM,EAE3C9L,GAAOA,GAAK,QAAQ6J,EAAE,KAAOkO,IAAqBD,EAAa,EAG/DjO,EAAE,OAAO,YAAciO,GACvBjO,EAAE,OAAO,kBAAoBkO,GAC7BlO,EAAE,MAAO,YAAcoO,EACzB,MACEjY,MAAO,MAAoB6J,EAAG3J,EAAO4L,CAAM,CAE/C,CAEA,IAAIoM,GAAgB,CAElB,KAAM,CACJ,MAAOlY,EACT,EAEA,WAAY6J,EAAE,OAAO,OAAO,OAAS,KAAW,MAAQ,KAAe,MAAQ,KAAe,OAC9F,WAAYA,EAAE,OAAO,OAAO,WAC5B,iBAAkBA,EAAE,OAAO,OAAO,iBAClC,YAAaA,EAAE,OAAO,OAAO,YAE7B,SAAUA,EAAE,OAAO,OAAO,OAAS,KAAW,OAC9C,UAAWA,EAAE,OAAO,OAAO,WAAa,EACxC,UAAWA,EAAE,OAAO,OAAO,UAE3B,EAAG,CACD,MAAOD,EACT,EACA,EAAG,CACD,MAAOC,CACT,EACA,MAAO,CAAC,EACR,KAAM,CAAC,EACP,MAAO4N,EACT,EAEI1a,IAAS,OACXmb,GAAI,MAAM,MAAQnb,IAGhByS,IAAQ,OACV0I,GAAI,KAAK,MAAQ1I,GACjB0I,GAAI,KAAK,IAAM1I,GAAK,OAAO,OAAO,WAAW,KAAO,EACpD0I,GAAI,KAAK,IAAM1I,GAAK,OAAO,OAAO,WAAW,KAAO,KAItDkI,GAAY,KAAKQ,EAAG,CACtB,CACF,CAAC,EAEGR,GAAY,OAKhBxX,EAAM,OAAO,QAASC,GAAU,CACZuX,GAAY,KAC5B,CAAC,CAAE,EAAA9N,GAAG,EAAAC,GAAG,MAAA9M,GAAO,KAAAyS,EAAK,IACnB5F,GAAE,QAAUzJ,GAAS0J,GAAE,QAAU1J,GAASpD,GAAM,QAAUoD,GAASqP,GAAK,QAAUrP,CACtF,GAGEsX,GAAW,KAAKtX,CAAK,CAEzB,CAAC,EAED4M,EAAO,KAAK,GAAG2K,EAAW,EAI9B,CAAC,CACH,CAAC,EAEG3K,EAAO,SAAW,EAEf,CAGL,IAAIoL,EAAa,EAGjBpL,EAAO,QAAQ,CAACrC,EAAGtN,IAAM,CACvB,GAAIsN,EAAE,MAAM,OAAS,KAAM,CAEzB,IAAI0N,EAAW1N,EAAE,EAAE,MAAM,OAAO,OAAS,CAAE,KAAM,IAAiB,cAAe,EAE7E5N,GAAQ,GAERsb,EAAS,OAAS,IAAiB,eACrCtb,GAAQma,EAAenB,EAAQqC,IAAerC,EAAQ,MAAM,CAAC,EACpDsC,EAAS,OAAS,IAAiB,QAC5Ctb,GAAQma,EAAemB,EAAS,UAAW,GAG7C1N,EAAE,MAAM,MAAQ5N,EAClB,CAEI4N,EAAE,KAAK,OAAS,OAElBA,EAAE,KAAK,MAAQA,EAAE,EAAE,MAAM,OAAO,OAAO,WAAW,OAAS,EAG/D,CAAC,EAED2N,GAAetL,CAAM,CAQvB,CAEA,OAAOA,CACT,CAGA,SAASsL,GAAetL,EAAoB,CAC1C,IAAIuL,EAAQvL,EAAO,IAAKrC,GAAMA,EAAE,KAAK,MAAM,MAAM,MAAM,CAAC,EAExD,KAAM,CAAE,OAAA6N,EAAQ,OAAAC,CAAO,EAAIC,GAA8BH,CAAK,GAE1DC,EAAS,KAAYC,EAAS,MAChCzL,EAAO,QAAQ,CAACrC,EAAGtN,IAAM,CACvBsN,EAAE,KAAK,MAAQ4N,EAAMlb,CAAC,EAAE,MAAMmb,EAAQD,EAAMlb,CAAC,EAAE,OAASob,CAAM,EAAE,KAAK,GAAG,CAC1E,CAAC,CAEL,CAEO,SAASE,GAAsBC,EAAgB,CACpD,IAAIL,EAAQK,EAAK,IAAKjO,GAAMA,EAAE,MAAM,MAAM,CAAC,EAEvC,CAAE,OAAA6N,EAAQ,OAAAC,CAAO,EAAIC,GAA8BH,CAAK,EAExDM,EAAIN,EAAM,CAAC,EAEf,GAAIM,EAAE,SAAW,GAAKL,IAAW,GAAKC,IAAW,EAC/C,MAAO,GAGT,IAAIK,EAAQ,CAAC,EAEb,OAAIN,EAAS,GACXM,EAAM,KAAK,GAAGD,EAAE,MAAM,EAAGL,CAAM,CAAC,EAG9BC,EAAS,GACXK,EAAM,KAAK,GAAGD,EAAE,MAAM,CAACJ,CAAM,CAAC,EAGzBK,EAAM,KAAK,GAAG,CACvB,CAGA,SAASJ,GAA8BH,EAAmB,CACxD,IAAIQ,EAAkB,IAClBC,EAAkB,IAGlBC,EAAkBV,EAAM,CAAC,EAE7B,QAASlb,EAAI,EAAGA,EAAIkb,EAAM,OAAQlb,IAC5Bkb,EAAMlb,CAAC,EAAE,OAAS4b,EAAM,SAC1BA,EAAQV,EAAMlb,CAAC,GAInB,QAASA,EAAI,EAAGA,EAAIkb,EAAM,OAAQlb,IAAK,CACrC,IAAI6b,EAAOX,EAAMlb,CAAC,EAElB,GAAI6b,IAASD,EAAO,CAElB,IAAIE,EAAS,EACb,QAASC,EAAI,EAAGA,EAAIH,EAAM,QACpBC,EAAKE,CAAC,IAAMH,EAAMG,CAAC,EADSA,IAE9BD,IAMAA,EAASJ,IACXA,EAAkBI,GAIpB,IAAIE,EAAS,EACb,QAASD,EAAIH,EAAM,OAAS,EAAGG,GAAK,GAC9BF,EAAKE,CAAC,IAAMH,EAAMG,CAAC,EADcA,IAEnCC,IAMAA,EAASL,IACXA,EAAkBK,EAEtB,CACF,CAEA,MAAO,CACL,OAAQN,EACR,OAAQC,CACV,CACF,C","sources":["webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipContent.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipHeader.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipColorIndicator.tsx","webpack://grafana/./packages/grafana-ui/src/components/VizTooltip/VizTooltipRow.tsx","webpack://grafana/./public/app/features/actions/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/BarChartLegend.tsx","webpack://grafana/./public/app/plugins/panel/barchart/bars.ts","webpack://grafana/./public/app/plugins/panel/barchart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/barchart/utils.ts","webpack://grafana/./public/app/plugins/panel/barchart/BarChartPanel.tsx","webpack://grafana/./public/app/plugins/panel/barchart/TickSpacingEditor.tsx","webpack://grafana/./public/app/plugins/panel/barchart/migrations.ts","webpack://grafana/./public/app/plugins/panel/barchart/suggestions.ts","webpack://grafana/./public/app/plugins/panel/barchart/module.tsx","webpack://grafana/./public/app/plugins/panel/canvas/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/status-history/utils.ts","webpack://grafana/./public/app/plugins/panel/timeseries/TimeSeriesTooltip.tsx","webpack://grafana/./public/app/plugins/panel/timeseries/utils.ts","webpack://grafana/./public/app/plugins/panel/xychart/panelcfg.gen.ts","webpack://grafana/./public/app/plugins/panel/xychart/utils.ts"],"sourcesContent":["import { css } from '@emotion/css';\nimport { CSSProperties, ReactNode } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\n\nimport { VizTooltipRow } from './VizTooltipRow';\nimport { VizTooltipItem } from './types';\n\ninterface VizTooltipContentProps {\n  items: VizTooltipItem[];\n  children?: ReactNode;\n  scrollable?: boolean;\n  isPinned: boolean;\n  maxHeight?: number;\n}\n\nexport const VizTooltipContent = ({\n  items,\n  children,\n  isPinned,\n  scrollable = false,\n  maxHeight,\n}: VizTooltipContentProps) => {\n  const styles = useStyles2(getStyles);\n\n  const scrollableStyle: CSSProperties = scrollable\n    ? {\n        maxHeight: maxHeight,\n        overflowY: 'auto',\n      }\n    : {};\n\n  return (\n    <div className={styles.wrapper} style={scrollableStyle}>\n      {items.map(({ label, value, color, colorIndicator, colorPlacement, isActive, lineStyle }, i) => (\n        <VizTooltipRow\n          key={i}\n          label={label}\n          value={value}\n          color={color}\n          colorIndicator={colorIndicator}\n          colorPlacement={colorPlacement}\n          isActive={isActive}\n          justify={'space-between'}\n          isPinned={isPinned}\n          lineStyle={lineStyle}\n          showValueScroll={!scrollable}\n        />\n      ))}\n      {children}\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    flex: 1,\n    gap: 2,\n    borderTop: `1px solid ${theme.colors.border.weak}`,\n    padding: theme.spacing(1),\n  }),\n});\n","import { css } from '@emotion/css';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\n\nimport { VizTooltipRow } from './VizTooltipRow';\nimport { VizTooltipItem } from './types';\n\ninterface Props {\n  item: VizTooltipItem;\n  isPinned: boolean;\n}\nexport const VizTooltipHeader = ({ item, isPinned }: Props) => {\n  const styles = useStyles2(getStyles);\n\n  const { label, value, color, colorIndicator } = item;\n\n  return (\n    <div className={styles.wrapper}>\n      <VizTooltipRow\n        label={label}\n        value={value}\n        color={color}\n        colorIndicator={colorIndicator}\n        marginRight={'22px'}\n        isPinned={isPinned}\n      />\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  wrapper: css({\n    display: 'flex',\n    flexDirection: 'column',\n    flex: 1,\n    padding: theme.spacing(1),\n    lineHeight: 1,\n  }),\n});\n","import { css, cx } from '@emotion/css';\n\nimport { FALLBACK_COLOR, GrafanaTheme2 } from '@grafana/data';\nimport { LineStyle } from '@grafana/schema';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\nimport { SeriesIcon } from '../VizLegend/SeriesIcon';\n\nimport { ColorIndicator, DEFAULT_COLOR_INDICATOR } from './types';\nimport { getColorIndicatorClass } from './utils';\n\nexport enum ColorIndicatorPosition {\n  Leading,\n  Trailing,\n}\n\ninterface Props {\n  color?: string;\n  colorIndicator?: ColorIndicator;\n  position?: ColorIndicatorPosition;\n  lineStyle?: LineStyle;\n}\n\nexport type ColorIndicatorStyles = ReturnType<typeof getStyles>;\n\nexport const VizTooltipColorIndicator = ({\n  color = FALLBACK_COLOR,\n  colorIndicator = DEFAULT_COLOR_INDICATOR,\n  position = ColorIndicatorPosition.Leading,\n  lineStyle,\n}: Props) => {\n  const styles = useStyles2(getStyles);\n\n  if (colorIndicator === ColorIndicator.series) {\n    return (\n      <SeriesIcon\n        color={color}\n        lineStyle={lineStyle}\n        className={position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing}\n      />\n    );\n  }\n\n  return (\n    <span\n      style={{ backgroundColor: color }}\n      className={cx(\n        position === ColorIndicatorPosition.Leading ? styles.leading : styles.trailing,\n        getColorIndicatorClass(colorIndicator, styles)\n      )}\n    />\n  );\n};\n\n// @TODO Update classes/add svgs\nconst getStyles = (theme: GrafanaTheme2) => ({\n  leading: css({\n    marginRight: theme.spacing(0.5),\n  }),\n  trailing: css({\n    marginLeft: theme.spacing(0.5),\n  }),\n  value: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.default,\n    fontWeight: 500,\n    minWidth: '12px',\n  }),\n  hexagon: css({}),\n  pie_1_4: css({}),\n  pie_2_4: css({}),\n  pie_3_4: css({}),\n  marker_sm: css({\n    width: '4px',\n    height: '4px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '4px',\n  }),\n  marker_md: css({\n    width: '8px',\n    height: '8px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '8px',\n  }),\n  marker_lg: css({\n    width: '12px',\n    height: '12px',\n    borderRadius: theme.shape.radius.circle,\n    minWidth: '12px',\n  }),\n});\n","import { css, cx } from '@emotion/css';\nimport { CSSProperties, ReactNode, useEffect, useRef, useState } from 'react';\nimport * as React from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\n\nimport { useStyles2 } from '../../themes/ThemeContext';\nimport { InlineToast } from '../InlineToast/InlineToast';\nimport { Tooltip } from '../Tooltip/Tooltip';\n\nimport { ColorIndicatorPosition, VizTooltipColorIndicator } from './VizTooltipColorIndicator';\nimport { ColorPlacement, VizTooltipItem } from './types';\n\ninterface VizTooltipRowProps extends Omit<VizTooltipItem, 'value'> {\n  value: string | number | null | ReactNode;\n  justify?: string;\n  isActive?: boolean; // for series list\n  marginRight?: string;\n  isPinned: boolean;\n  showValueScroll?: boolean;\n}\n\nenum LabelValueTypes {\n  label = 'label',\n  value = 'value',\n}\n\nconst SUCCESSFULLY_COPIED_TEXT = 'Copied to clipboard';\nconst SHOW_SUCCESS_DURATION = 2 * 1000;\nconst HORIZONTAL_PX_PER_CHAR = 7;\n\nexport const VizTooltipRow = ({\n  label,\n  value,\n  color,\n  colorIndicator,\n  colorPlacement = ColorPlacement.first,\n  justify = 'flex-start',\n  isActive = false,\n  marginRight = '0px',\n  isPinned,\n  lineStyle,\n  showValueScroll,\n}: VizTooltipRowProps) => {\n  const styles = useStyles2(getStyles, justify, marginRight);\n\n  const innerValueScrollStyle: CSSProperties = showValueScroll\n    ? {\n        maxHeight: 55,\n        whiteSpace: 'wrap',\n        wordBreak: 'break-word',\n        overflowY: 'auto',\n      }\n    : {\n        whiteSpace: 'pre-line',\n        wordBreak: 'break-word',\n        lineHeight: 1.2,\n      };\n\n  const [showLabelTooltip, setShowLabelTooltip] = useState(false);\n\n  const [copiedText, setCopiedText] = useState<Record<string, string> | null>(null);\n  const [showCopySuccess, setShowCopySuccess] = useState(false);\n\n  const labelRef = useRef<null | HTMLDivElement>(null);\n  const valueRef = useRef<null | HTMLDivElement>(null);\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n\n    if (showCopySuccess) {\n      timeoutId = setTimeout(() => {\n        setShowCopySuccess(false);\n      }, SHOW_SUCCESS_DURATION);\n    }\n\n    return () => {\n      window.clearTimeout(timeoutId);\n    };\n  }, [showCopySuccess]);\n\n  const copyToClipboard = async (text: string, type: LabelValueTypes) => {\n    if (!(navigator?.clipboard && window.isSecureContext)) {\n      fallbackCopyToClipboard(text, type);\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopiedText({ [`${type}`]: text });\n      setShowCopySuccess(true);\n    } catch (error) {\n      setCopiedText(null);\n    }\n  };\n\n  const fallbackCopyToClipboard = (text: string, type: LabelValueTypes) => {\n    // Use a fallback method for browsers/contexts that don't support the Clipboard API.\n    const textarea = document.createElement('textarea');\n    labelRef.current?.appendChild(textarea);\n    textarea.value = text;\n    textarea.focus();\n    textarea.select();\n    try {\n      const successful = document.execCommand('copy');\n      if (successful) {\n        setCopiedText({ [`${type}`]: text });\n        setShowCopySuccess(true);\n      }\n    } catch (err) {\n      console.error('Unable to copy to clipboard', err);\n    }\n\n    textarea.remove();\n  };\n\n  const onMouseEnterLabel = (event: React.MouseEvent<HTMLDivElement>) => {\n    if (event.currentTarget.offsetWidth < event.currentTarget.scrollWidth) {\n      setShowLabelTooltip(true);\n    }\n  };\n\n  const onMouseLeaveLabel = () => setShowLabelTooltip(false);\n\n  // if label is > 50% window width, try to put label/value pairs on new lines\n  if (label.length * HORIZONTAL_PX_PER_CHAR > window.innerWidth / 2) {\n    label = label.replaceAll('{', '{\\n  ').replaceAll('}', '\\n}').replaceAll(', ', ',\\n  ');\n  }\n\n  return (\n    <div className={styles.contentWrapper}>\n      {(color || label) && (\n        <div className={styles.valueWrapper}>\n          {color && colorPlacement === ColorPlacement.first && (\n            <VizTooltipColorIndicator color={color} colorIndicator={colorIndicator} lineStyle={lineStyle} />\n          )}\n          {!isPinned ? (\n            <div className={cx(styles.label, isActive && styles.activeSeries)}>{label}</div>\n          ) : (\n            <>\n              <Tooltip content={label} interactive={false} show={showLabelTooltip}>\n                <>\n                  {showCopySuccess && copiedText?.label && (\n                    <InlineToast placement=\"top\" referenceElement={labelRef.current}>\n                      {SUCCESSFULLY_COPIED_TEXT}\n                    </InlineToast>\n                  )}\n                  {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n                  <div\n                    className={cx(styles.label, isActive && styles.activeSeries, navigator?.clipboard && styles.copy)}\n                    onMouseEnter={onMouseEnterLabel}\n                    onMouseLeave={onMouseLeaveLabel}\n                    onClick={() => copyToClipboard(label, LabelValueTypes.label)}\n                    ref={labelRef}\n                  >\n                    {label}\n                  </div>\n                </>\n              </Tooltip>\n            </>\n          )}\n        </div>\n      )}\n\n      <div className={styles.valueWrapper}>\n        {color && colorPlacement === ColorPlacement.leading && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Leading}\n            lineStyle={lineStyle}\n          />\n        )}\n\n        {!isPinned ? (\n          <div className={cx(styles.value, isActive)} style={innerValueScrollStyle}>\n            {value}\n          </div>\n        ) : (\n          <>\n            {showCopySuccess && copiedText?.value && (\n              <InlineToast placement=\"top\" referenceElement={valueRef.current}>\n                {SUCCESSFULLY_COPIED_TEXT}\n              </InlineToast>\n            )}\n            {/* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions */}\n            <div\n              className={cx(styles.value, isActive, navigator?.clipboard && styles.copy)}\n              style={innerValueScrollStyle}\n              onClick={() => copyToClipboard(value ? value.toString() : '', LabelValueTypes.value)}\n              ref={valueRef}\n            >\n              {value}\n            </div>\n          </>\n        )}\n\n        {color && colorPlacement === ColorPlacement.trailing && (\n          <VizTooltipColorIndicator\n            color={color}\n            colorIndicator={colorIndicator}\n            position={ColorIndicatorPosition.Trailing}\n            lineStyle={lineStyle}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2, justify: string, marginRight: string) => ({\n  contentWrapper: css({\n    display: 'flex',\n    alignItems: 'start',\n    justifyContent: justify,\n    marginRight: marginRight,\n  }),\n  label: css({\n    color: theme.colors.text.secondary,\n    fontWeight: 400,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n    marginRight: theme.spacing(2),\n  }),\n  value: css({\n    fontWeight: 500,\n    textOverflow: 'ellipsis',\n    overflow: 'hidden',\n  }),\n  valueWrapper: css({\n    display: 'flex',\n    alignItems: 'center',\n  }),\n  activeSeries: css({\n    fontWeight: theme.typography.fontWeightBold,\n    color: theme.colors.text.maxContrast,\n  }),\n  copy: css({\n    cursor: 'pointer',\n  }),\n});\n","import {\n  Action,\n  ActionModel,\n  ActionVariableInput,\n  AppEvents,\n  DataContextScopedVar,\n  DataFrame,\n  DataLink,\n  Field,\n  FieldType,\n  getFieldDataContextClone,\n  InterpolateFunction,\n  ScopedVars,\n  textUtil,\n  ValueLinkConfig,\n} from '@grafana/data';\nimport { BackendSrvRequest, config as grafanaConfig, getBackendSrv } from '@grafana/runtime';\nimport { appEvents } from 'app/core/core';\n\nimport { HttpRequestMethod } from '../../plugins/panel/canvas/panelcfg.gen';\nimport { createAbsoluteUrl, RelativeUrl } from '../alerting/unified/utils/url';\n\n/** @internal */\nexport const genReplaceActionVars = (\n  boundReplaceVariables: InterpolateFunction,\n  action: Action,\n  actionVars?: ActionVariableInput\n): InterpolateFunction => {\n  return (value, scopedVars, format) => {\n    if (action.variables && actionVars) {\n      value = value.replace(/\\$\\w+/g, (matched) => {\n        const name = matched.slice(1);\n\n        if (action.variables!.some((action) => action.key === name) && actionVars[name] != null) {\n          return actionVars[name];\n        }\n\n        return matched;\n      });\n    }\n\n    return boundReplaceVariables(value, scopedVars, format);\n  };\n};\n\n/** @internal */\nexport const getActions = (\n  frame: DataFrame,\n  field: Field,\n  fieldScopedVars: ScopedVars,\n  replaceVariables: InterpolateFunction,\n  actions: Action[],\n  config: ValueLinkConfig\n): Array<ActionModel<Field>> => {\n  if (!actions || actions.length === 0) {\n    return [];\n  }\n\n  const actionModels = actions.map((action: Action) => {\n    const dataContext: DataContextScopedVar = getFieldDataContextClone(frame, field, fieldScopedVars);\n    const actionScopedVars = {\n      ...fieldScopedVars,\n      __dataContext: dataContext,\n    };\n\n    const boundReplaceVariables: InterpolateFunction = (value, scopedVars, format) => {\n      return replaceVariables(value, { ...actionScopedVars, ...scopedVars }, format);\n    };\n\n    // We are not displaying reduction result\n    if (config.valueRowIndex !== undefined && !isNaN(config.valueRowIndex)) {\n      dataContext.value.rowIndex = config.valueRowIndex;\n    } else {\n      dataContext.value.calculatedValue = config.calculatedValue;\n    }\n\n    const actionModel: ActionModel<Field> = {\n      title: replaceVariables(action.title, actionScopedVars),\n      confirmation: (actionVars?: ActionVariableInput) =>\n        genReplaceActionVars(\n          boundReplaceVariables,\n          action,\n          actionVars\n        )(action.confirmation || `Are you sure you want to ${action.title}?`),\n      onClick: (evt: MouseEvent, origin: Field, actionVars?: ActionVariableInput) => {\n        let request = buildActionRequest(action, genReplaceActionVars(boundReplaceVariables, action, actionVars));\n\n        try {\n          getBackendSrv()\n            .fetch(request)\n            .subscribe({\n              error: (error) => {\n                appEvents.emit(AppEvents.alertError, ['An error has occurred. Check console output for more details.']);\n                console.error(error);\n              },\n              complete: () => {\n                appEvents.emit(AppEvents.alertSuccess, ['API call was successful']);\n              },\n            });\n        } catch (error) {\n          appEvents.emit(AppEvents.alertError, ['An error has occurred. Check console output for more details.']);\n          console.error(error);\n          return;\n        }\n      },\n      oneClick: action.oneClick ?? false,\n      style: {\n        backgroundColor: action.style?.backgroundColor ?? grafanaConfig.theme2.colors.secondary.main,\n      },\n      variables: action.variables,\n    };\n\n    return actionModel;\n  });\n\n  return actionModels.filter((action): action is ActionModel => !!action);\n};\n\n/** @internal */\nexport const buildActionRequest = (action: Action, replaceVariables: InterpolateFunction) => {\n  const url = new URL(getUrl(replaceVariables(action.fetch.url)));\n\n  const requestHeaders: Record<string, string> = {};\n\n  let request: BackendSrvRequest = {\n    url: url.toString(),\n    method: action.fetch.method,\n    data: getData(action, replaceVariables),\n    headers: requestHeaders,\n  };\n\n  if (action.fetch.headers) {\n    action.fetch.headers.forEach(([name, value]) => {\n      requestHeaders[replaceVariables(name)] = replaceVariables(value);\n    });\n  }\n\n  if (action.fetch.queryParams) {\n    action.fetch.queryParams?.forEach(([name, value]) => {\n      url.searchParams.append(replaceVariables(name), replaceVariables(value));\n    });\n\n    request.url = url.toString();\n  }\n\n  requestHeaders['X-Grafana-Action'] = '1';\n  request.headers = requestHeaders;\n\n  return request;\n};\n\n/** @internal */\n// @TODO update return type\nexport const getActionsDefaultField = (dataLinks: DataLink[] = [], actions: Action[] = []) => {\n  return {\n    name: 'Default field',\n    type: FieldType.string,\n    config: { links: dataLinks, actions: actions },\n    values: [],\n  };\n};\n\n/** @internal */\nconst getUrl = (endpoint: string) => {\n  const isRelativeUrl = endpoint.startsWith('/');\n  if (isRelativeUrl) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const sanitizedRelativeURL = textUtil.sanitizeUrl(endpoint) as RelativeUrl;\n    endpoint = createAbsoluteUrl(sanitizedRelativeURL, []);\n  }\n\n  return endpoint;\n};\n\n/** @internal */\nconst getData = (action: Action, replaceVariables: InterpolateFunction) => {\n  let data: string | undefined = action.fetch.body ? replaceVariables(action.fetch.body) : '{}';\n  if (action.fetch.method === HttpRequestMethod.GET) {\n    data = undefined;\n  }\n\n  return data;\n};\n","import { includes } from 'lodash';\nimport { memo } from 'react';\n\nimport {\n  DataFrame,\n  Field,\n  FieldColorModeId,\n  getFieldSeriesColor,\n  ThresholdsConfig,\n  ThresholdsMode,\n  ValueMapping,\n} from '@grafana/data';\nimport { VizLegendOptions, AxisPlacement } from '@grafana/schema';\nimport { UPlotConfigBuilder, VizLayout, VizLayoutLegendProps, VizLegend, VizLegendItem, useTheme2 } from '@grafana/ui';\nimport { getDisplayValuesForCalcs } from '@grafana/ui/internal';\nimport { getThresholdItems, getValueMappingItems } from 'app/core/components/TimelineChart/utils';\ninterface BarChartLegend2Props extends VizLegendOptions, Omit<VizLayoutLegendProps, 'children'> {\n  data: DataFrame[];\n  colorField?: Field | null;\n  // config: UPlotConfigBuilder;\n}\n\n/**\n * mostly duplicates logic in PlotLegend below :(\n *\n * @internal\n */\nexport function hasVisibleLegendSeries(config: UPlotConfigBuilder, data: DataFrame[]) {\n  return data[0].fields.slice(1).some((field) => !Boolean(field.config.custom?.hideFrom?.legend));\n\n  // return config.getSeries().some((s, i) => {\n  //   const frameIndex = 0;\n  //   const fieldIndex = i + 1;\n  //   const field = data[frameIndex].fields[fieldIndex];\n  //   return !Boolean(field.config.custom?.hideFrom?.legend);\n  // });\n}\n\nexport const BarChartLegend = memo(\n  ({ data, placement, calcs, displayMode, colorField, ...vizLayoutLegendProps }: BarChartLegend2Props) => {\n    const theme = useTheme2();\n\n    const fieldConfig = data[0].fields[0].config;\n    const colorMode = fieldConfig.color?.mode;\n\n    const thresholdItems: VizLegendItem[] = [];\n    if (colorMode === FieldColorModeId.Thresholds) {\n      const thresholdsAbsolute: ThresholdsConfig = { mode: ThresholdsMode.Absolute, steps: [] };\n      const thresholdsPercent: ThresholdsConfig = { mode: ThresholdsMode.Percentage, steps: [] };\n\n      for (let i = 1; i < data[0].fields.length; i++) {\n        const field = data[0].fields[i];\n        // there is no reason to add threshold with only one (Base) step\n        if (field.config.thresholds && field.config.thresholds.steps.length > 1) {\n          if (field.config.thresholds.mode === ThresholdsMode.Absolute) {\n            for (const step of field.config.thresholds.steps) {\n              if (!includes(thresholdsAbsolute.steps, step)) {\n                thresholdsAbsolute.steps.push(step);\n              }\n            }\n          } else {\n            for (const step of field.config.thresholds.steps) {\n              if (!includes(thresholdsPercent.steps, step)) {\n                thresholdsPercent.steps.push(step);\n              }\n            }\n          }\n        }\n      }\n\n      const thresholdAbsoluteItems: VizLegendItem[] = getThresholdItems(fieldConfig, theme, thresholdsAbsolute);\n      const thresholdPercentItems: VizLegendItem[] = getThresholdItems(fieldConfig, theme, thresholdsPercent);\n      thresholdItems.push(...thresholdAbsoluteItems, ...thresholdPercentItems);\n    }\n\n    const valueMappings: ValueMapping[] = [];\n    for (let i = 1; i < data[0].fields.length; i++) {\n      const mappings = data[0].fields[i].config.mappings;\n      if (mappings) {\n        for (const mapping of mappings) {\n          if (!includes(valueMappings, mapping)) {\n            valueMappings.push(mapping);\n          }\n        }\n      }\n    }\n    const valueMappingItems: VizLegendItem[] = getValueMappingItems(valueMappings, theme);\n\n    const legendItems = data[0].fields\n      .slice(1)\n      .map((field, i) => {\n        const frameIndex = 0;\n        const fieldIndex = i + 1;\n        // const axisPlacement = config.getAxisPlacement(s.props.scaleKey); // TODO: this should be stamped on the field.config?\n        // const field = data[frameIndex].fields[fieldIndex];\n\n        if (!field || field.config.custom?.hideFrom?.legend) {\n          return undefined;\n        }\n\n        // // apparently doing a second pass like this will take existing state.displayName, and if same as another one, appends counter\n        // const label = getFieldDisplayName(field, data[0], data);\n        const label = field.state?.displayName ?? field.name;\n\n        const color = getFieldSeriesColor(field, theme).color;\n\n        const item: VizLegendItem = {\n          disabled: field.state?.hideFrom?.viz,\n          color,\n          label,\n          yAxis: field.config.custom?.axisPlacement === AxisPlacement.Right ? 2 : 1,\n          getDisplayValues: () => getDisplayValuesForCalcs(calcs, field, theme),\n          getItemKey: () => `${label}-${frameIndex}-${fieldIndex}`,\n        };\n\n        return item;\n      })\n      .filter((i): i is VizLegendItem => i !== undefined);\n\n    return (\n      <VizLayout.Legend placement={placement} {...vizLayoutLegendProps}>\n        <VizLegend\n          placement={placement}\n          items={legendItems}\n          thresholdItems={thresholdItems}\n          mappingItems={valueMappingItems}\n          displayMode={displayMode}\n          sortBy={vizLayoutLegendProps.sortBy}\n          sortDesc={vizLayoutLegendProps.sortDesc}\n          isSortable={true}\n        />\n      </VizLayout.Legend>\n    );\n  }\n);\n\nBarChartLegend.displayName = 'BarChartLegend';\n","import uPlot, { Axis, AlignedData, Scale } from 'uplot';\n\nimport { colorManipulator, DataFrame, dateTimeFormat, GrafanaTheme2, systemDateFormats, TimeZone } from '@grafana/data';\nimport {\n  StackingMode,\n  VisibilityMode,\n  ScaleDirection,\n  ScaleOrientation,\n  VizTextDisplayOptions,\n  VizLegendOptions,\n} from '@grafana/schema';\nimport { measureText } from '@grafana/ui';\nimport { timeUnitSize, StackingGroup, preparePlotData2 } from '@grafana/ui/internal';\n\nconst intervals = systemDateFormats.interval;\n\nimport { distribute, SPACE_BETWEEN } from './distribute';\nimport { findRects, intersects, pointWithin, Quadtree, Rect } from './quadtree';\n\nconst groupDistr = SPACE_BETWEEN;\nconst barDistr = SPACE_BETWEEN;\n// min.max font size for value label\nconst VALUE_MIN_FONT_SIZE = 8;\nconst VALUE_MAX_FONT_SIZE = 30;\n// % of width/height of the bar that value should fit in when measuring size\nconst BAR_FONT_SIZE_RATIO = 0.65;\n// distance between label and a bar in % of bar width\nconst LABEL_OFFSET_FACTOR_VT = 0.1;\nconst LABEL_OFFSET_FACTOR_HZ = 0.15;\n// max distance\nconst LABEL_OFFSET_MAX_VT = 5;\nconst LABEL_OFFSET_MAX_HZ = 10;\n\n// text baseline middle runs through the middle of lowercase letters\n// since bar values are numbers and uppercase-like, we want the middle of uppercase\n// this is a cheap fudge factor that skips expensive and inconsistent cross-browser measuring\nconst MIDDLE_BASELINE_SHIFT = 0.1;\n\n/**\n * @internal\n */\nexport interface BarsOptions {\n  xOri: ScaleOrientation;\n  xDir: ScaleDirection;\n  groupWidth: number;\n  barWidth: number;\n  barRadius: number;\n  showValue: VisibilityMode;\n  stacking: StackingMode;\n  rawValue: (seriesIdx: number, valueIdx: number) => number | null;\n  getColor?: (seriesIdx: number, valueIdx: number, value: unknown) => string | null;\n  fillOpacity?: number;\n  formatValue: (seriesIdx: number, value: unknown) => string;\n  formatShortValue: (seriesIdx: number, value: unknown) => string;\n  timeZone?: TimeZone;\n  text?: VizTextDisplayOptions;\n  hoverMulti?: boolean;\n  legend?: VizLegendOptions;\n  xSpacing?: number;\n  xTimeAuto?: boolean;\n  negY?: boolean[];\n  fullHighlight?: boolean;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelTable {\n  [index: number]: ValueLabelArray;\n}\n\n/**\n * @internal\n */\ninterface ValueLabelArray {\n  [index: number]: ValueLabel;\n}\n\n/**\n * @internal\n */\ninterface ValueLabel {\n  text: string;\n  value: number | null;\n  hidden: boolean;\n  bbox?: Rect;\n  textMetrics?: TextMetrics;\n  x?: number;\n  y?: number;\n}\n\n/**\n * @internal\n */\nfunction calculateFontSizeWithMetrics(\n  text: string,\n  width: number,\n  height: number,\n  lineHeight: number,\n  maxSize?: number\n) {\n  // calculate width in 14px\n  const textSize = measureText(text, 14);\n  // how much bigger than 14px can we make it while staying within our width constraints\n  const fontSizeBasedOnWidth = (width / (textSize.width + 2)) * 14;\n  const fontSizeBasedOnHeight = height / lineHeight;\n\n  // final fontSize\n  const optimalSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);\n  return {\n    fontSize: Math.min(optimalSize, maxSize ?? optimalSize),\n    textMetrics: textSize,\n  };\n}\n\n/**\n * @internal\n */\nexport function getConfig(opts: BarsOptions, theme: GrafanaTheme2) {\n  const {\n    xOri,\n    xDir: dir,\n    rawValue,\n    getColor,\n    formatValue,\n    formatShortValue,\n    fillOpacity = 1,\n    showValue,\n    xSpacing = 0,\n    hoverMulti = false,\n    timeZone = 'browser',\n  } = opts;\n  const isXHorizontal = xOri === ScaleOrientation.Horizontal;\n  const hasAutoValueSize = !Boolean(opts.text?.valueSize);\n  const isStacked = opts.stacking !== StackingMode.None;\n  const pctStacked = opts.stacking === StackingMode.Percent;\n\n  let { groupWidth, barWidth, barRadius = 0 } = opts;\n\n  if (isStacked) {\n    [groupWidth, barWidth] = [barWidth, groupWidth];\n  }\n\n  let qt: Quadtree;\n  const numSeries = 30; // !!\n  const hovered: Array<Rect | null> = Array(numSeries).fill(null);\n  let hRect: Rect | null;\n\n  // for distr: 2 scales, the splits array should contain indices into data[0] rather than values\n  const xSplits: Axis.Splits | undefined = (u) => Array.from(u.data[0].map((v, i) => i));\n\n  const hFilter: Axis.Filter | undefined =\n    xSpacing === 0\n      ? undefined\n      : (u, splits) => {\n          // hSpacing?\n          const dim = u.bbox.width;\n          const _dir = dir * (isXHorizontal ? 1 : -1);\n\n          let dataLen = splits.length;\n          let lastIdx = dataLen - 1;\n\n          let skipMod = 0;\n\n          let cssDim = dim / uPlot.pxRatio;\n          let maxTicks = Math.abs(Math.floor(cssDim / xSpacing));\n\n          skipMod = dataLen < maxTicks ? 0 : Math.ceil(dataLen / maxTicks);\n\n          let splits2 = splits.map((v, i) => {\n            let shouldSkip = skipMod !== 0 && (xSpacing > 0 ? i : lastIdx - i) % skipMod > 0;\n            return shouldSkip ? null : v;\n          });\n\n          return _dir === 1 ? splits2 : splits2.reverse();\n        };\n\n  // the splits passed into here are data[0] values looked up by the indices returned from splits()\n  const xValues: Axis.Values = (u, splits, axisIdx, foundSpace, foundIncr) => {\n    if (opts.xTimeAuto) {\n      let format = intervals.year;\n\n      if (foundIncr < timeUnitSize.second) {\n        format = intervals.millisecond;\n      } else if (foundIncr < timeUnitSize.minute) {\n        format = intervals.second;\n      } else if (foundIncr < timeUnitSize.hour) {\n        format = intervals.minute;\n      } else if (foundIncr < timeUnitSize.day) {\n        format = intervals.hour;\n      } else if (foundIncr < timeUnitSize.month) {\n        format = intervals.day;\n      } else if (foundIncr < timeUnitSize.year) {\n        format = intervals.month;\n      } else {\n        format = intervals.year;\n      }\n\n      return splits.map((v) => (v == null ? '' : dateTimeFormat(v, { format, timeZone })));\n    }\n\n    return splits.map((v) => (isXHorizontal ? formatShortValue(0, v) : formatValue(0, v)));\n  };\n\n  // this expands the distr: 2 scale so that the indicies of each data[0] land at the proper justified positions\n  const xRange: Scale.Range = (u, min, max) => {\n    min = 0;\n    max = Math.max(1, u.data[0].length - 1);\n\n    let pctOffset = 0;\n\n    // how far in is the first tick in % of full dimension\n    distribute(u.data[0].length, groupWidth, groupDistr, 0, (di, lftPct, widPct) => {\n      pctOffset = lftPct + widPct / 2;\n    });\n\n    // expand scale range by equal amounts on both ends\n    let rn = max - min;\n\n    if (pctOffset === 0.5) {\n      min -= rn;\n    } else {\n      let upScale = 1 / (1 - pctOffset * 2);\n      let offset = (upScale * rn - rn) / 2;\n\n      min -= offset;\n      max += offset;\n    }\n\n    return [min, max];\n  };\n\n  let distrTwo = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct + groupDimPct * barOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct * barDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  let distrOne = (groupCount: number, barCount: number) => {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distribute(groupCount, groupWidth, groupDistr, null, (groupIdx, groupOffPct, groupDimPct) => {\n      distribute(barCount, barWidth, barDistr, null, (barIdx, barOffPct, barDimPct) => {\n        out[barIdx].offs[groupIdx] = groupOffPct;\n        out[barIdx].size[groupIdx] = groupDimPct;\n      });\n    });\n\n    return out;\n  };\n\n  const LABEL_OFFSET_FACTOR = isXHorizontal ? LABEL_OFFSET_FACTOR_VT : LABEL_OFFSET_FACTOR_HZ;\n  const LABEL_OFFSET_MAX = isXHorizontal ? LABEL_OFFSET_MAX_VT : LABEL_OFFSET_MAX_HZ;\n\n  let barsPctLayout: Array<null | { offs: number[]; size: number[] }> = [];\n  let barsColors: Array<null | { fill: Array<string | null>; stroke: Array<string | null> }> = [];\n  let scaleFactor = 1;\n  let labels: ValueLabelTable;\n  let fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n  let labelOffset = LABEL_OFFSET_MAX;\n\n  // minimum available space for labels between bar end and plotting area bound (in canvas pixels)\n  let vSpace = Infinity;\n  let hSpace = Infinity;\n\n  let useMappedColors = getColor != null;\n\n  let mappedColorDisp = useMappedColors\n    ? {\n        fill: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.fill,\n        },\n        stroke: {\n          unit: 3,\n          values: (u: uPlot, seriesIdx: number) => barsColors[seriesIdx]!.stroke,\n        },\n      }\n    : {};\n\n  let barsBuilder = uPlot.paths.bars!({\n    radius: pctStacked\n      ? 0\n      : !isStacked\n        ? barRadius\n        : (u: uPlot, seriesIdx: number) => {\n            let isTopmostSeries = seriesIdx === u.data.length - 1;\n            return isTopmostSeries ? [barRadius, 0] : [0, 0];\n          },\n    disp: {\n      x0: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.offs,\n      },\n      size: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx]!.size,\n      },\n      ...mappedColorDisp,\n    },\n    // collect rendered bar geometry\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      // we get back raw canvas coords (included axes & padding)\n      // translate to the plotting area origin\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n\n      let val = u.data[seriesIdx][dataIdx]!;\n      // accum min space abvailable for labels\n      if (isXHorizontal) {\n        vSpace = Math.min(vSpace, val < 0 ? u.bbox.height - (top + hgt) : top);\n        hSpace = wid;\n      } else {\n        vSpace = hgt;\n        hSpace = Math.min(hSpace, val < 0 ? lft : u.bbox.width - (lft + wid));\n      }\n\n      let barRect = { x: lft, y: top, w: wid, h: hgt, sidx: seriesIdx, didx: dataIdx };\n\n      if (!isStacked && opts.fullHighlight) {\n        if (opts.xOri === ScaleOrientation.Horizontal) {\n          barRect.y = 0;\n          barRect.h = u.bbox.height;\n        } else {\n          barRect.x = 0;\n          barRect.w = u.bbox.width;\n        }\n      }\n\n      qt.add(barRect);\n\n      if (showValue !== VisibilityMode.Never) {\n        const raw = rawValue(seriesIdx, dataIdx)!;\n        let divider = 1;\n\n        if (pctStacked && alignedTotals![seriesIdx][dataIdx]!) {\n          divider = alignedTotals![seriesIdx][dataIdx]!;\n        }\n\n        const v = divider === 0 ? 0 : raw / divider;\n        // Format Values and calculate label offsets\n        const text = formatValue(seriesIdx, v);\n        labelOffset = Math.min(labelOffset, Math.round(LABEL_OFFSET_FACTOR * (isXHorizontal ? wid : hgt)));\n\n        if (labels[dataIdx] === undefined) {\n          labels[dataIdx] = {};\n        }\n        labels[dataIdx][seriesIdx] = { text: text, value: rawValue(seriesIdx, dataIdx), hidden: false };\n\n        // Calculate font size when it's set to be automatic\n        if (hasAutoValueSize) {\n          const { fontSize: calculatedSize, textMetrics } = calculateFontSizeWithMetrics(\n            labels[dataIdx][seriesIdx].text,\n            hSpace * (isXHorizontal ? BAR_FONT_SIZE_RATIO : 1) - (isXHorizontal ? 0 : labelOffset),\n            vSpace * (isXHorizontal ? 1 : BAR_FONT_SIZE_RATIO) - (isXHorizontal ? labelOffset : 0),\n            1\n          );\n\n          // Save text metrics\n          labels[dataIdx][seriesIdx].textMetrics = textMetrics;\n\n          // Retrieve the new font size and use it\n          let autoFontSize = Math.round(Math.min(fontSize, VALUE_MAX_FONT_SIZE, calculatedSize));\n\n          // Calculate the scaling factor for bouding boxes\n          // Take into account the fact that calculateFontSize\n          // uses 14px measurement so we need to adjust the scale factor\n          scaleFactor = (autoFontSize / fontSize) * (autoFontSize / 14);\n\n          // Update the end font-size\n          fontSize = autoFontSize;\n        } else {\n          labels[dataIdx][seriesIdx].textMetrics = measureText(labels[dataIdx][seriesIdx].text, fontSize);\n        }\n\n        let middleShift = isXHorizontal ? 0 : -Math.round(MIDDLE_BASELINE_SHIFT * fontSize);\n        let value = rawValue(seriesIdx, dataIdx);\n\n        if (opts.negY?.[seriesIdx] && value != null) {\n          value *= -1;\n        }\n\n        if (value != null) {\n          // Calculate final co-ordinates for text position\n          const x =\n            u.bbox.left + (isXHorizontal ? lft + wid / 2 : value < 0 ? lft - labelOffset : lft + wid + labelOffset);\n          let y =\n            u.bbox.top +\n            (isXHorizontal ? (value < 0 ? top + hgt + labelOffset : top - labelOffset) : top + hgt / 2 - middleShift);\n\n          // Retrieve textMetrics with necessary default values\n          // These _shouldn't_ be undefined at this point\n          // but they _could_ be.\n          const {\n            textMetrics = {\n              width: 1,\n              actualBoundingBoxAscent: 1,\n              actualBoundingBoxDescent: 1,\n            },\n          } = labels[dataIdx][seriesIdx];\n\n          // Adjust bounding boxes based on text scale\n          // factor and orientation (which changes the baseline)\n          let xAdjust = 0,\n            yAdjust = 0;\n\n          if (isXHorizontal) {\n            // Adjust for baseline which is \"top\" in this case\n            xAdjust = (textMetrics.width * scaleFactor) / 2;\n\n            // yAdjust only matters when the value isn't negative\n            yAdjust =\n              value > 0\n                ? (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor\n                : 0;\n          } else {\n            // Adjust from the baseline which is \"middle\" in this case\n            yAdjust = ((textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor) / 2;\n\n            // Adjust for baseline being \"right\" in the x direction\n            xAdjust = value < 0 ? textMetrics.width * scaleFactor : 0;\n          }\n\n          // Force label bounding box y position to not be negative\n          if (y - yAdjust < 0) {\n            y = yAdjust;\n          }\n\n          // Construct final bounding box for the label text\n          labels[dataIdx][seriesIdx].x = x;\n          labels[dataIdx][seriesIdx].y = y;\n          labels[dataIdx][seriesIdx].bbox = {\n            x: x - xAdjust,\n            y: y - yAdjust,\n            w: textMetrics.width * scaleFactor,\n            h: (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) * scaleFactor,\n          };\n        }\n      }\n    },\n  });\n\n  const init = (u: uPlot) => {\n    u.root.querySelectorAll<HTMLDivElement>('.u-cursor-pt').forEach((el) => {\n      el.style.borderRadius = '0';\n\n      if (opts.fullHighlight) {\n        el.style.zIndex = '-1';\n      }\n    });\n  };\n\n  const cursor: uPlot.Cursor = {\n    x: false,\n    y: false,\n    drag: {\n      x: false,\n      y: false,\n    },\n    dataIdx: (u, seriesIdx) => {\n      if (seriesIdx === 0) {\n        hovered.fill(null);\n        hRect = null;\n\n        let cx = u.cursor.left! * uPlot.pxRatio;\n        let cy = u.cursor.top! * uPlot.pxRatio;\n\n        qt.get(cx, cy, 1, 1, (o) => {\n          if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n            hRect = hovered[0] = o;\n            hovered[hRect.sidx] = hRect;\n\n            hoverMulti &&\n              findRects(qt, undefined, hRect.didx).forEach((r) => {\n                hovered[r.sidx] = r;\n              });\n          }\n        });\n      }\n\n      return hovered[seriesIdx]?.didx;\n    },\n    points: {\n      fill: 'rgba(255,255,255,0.4)',\n      bbox: (u, seriesIdx) => {\n        let hRect2 = hovered[seriesIdx];\n        let isHovered = hRect2 != null;\n\n        return {\n          left: isHovered ? hRect2!.x / uPlot.pxRatio : -10,\n          top: isHovered ? hRect2!.y / uPlot.pxRatio : -10,\n          width: isHovered ? hRect2!.w / uPlot.pxRatio : 0,\n          height: isHovered ? hRect2!.h / uPlot.pxRatio : 0,\n        };\n      },\n    },\n    focus: {\n      prox: 1e3,\n      dist: (u, seriesIdx) => (hRect?.sidx === seriesIdx ? 0 : Infinity),\n    },\n  };\n\n  // Build bars\n  const drawClear = (u: uPlot) => {\n    qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n    qt.clear();\n\n    // clear the path cache to force drawBars() to rebuild new quadtree\n    u.series.forEach((s) => {\n      // @ts-ignore\n      s._paths = null;\n    });\n\n    if (isStacked) {\n      barsPctLayout = [null, ...distrOne(u.data[0].length, u.data.length - 1)];\n    } else {\n      barsPctLayout = [null, ...distrTwo(u.data[0].length, u.data.length - 1)];\n    }\n\n    if (useMappedColors) {\n      barsColors = [null];\n\n      // map per-bar colors\n      for (let i = 1; i < u.data.length; i++) {\n        let colors = (u.data[i] as Array<number | null>).map((value, valueIdx) => {\n          if (value != null) {\n            return getColor!(i, valueIdx, value);\n          }\n\n          return null;\n        });\n\n        barsColors.push({\n          fill:\n            fillOpacity < 1 ? colors.map((c) => (c != null ? colorManipulator.alpha(c, fillOpacity) : null)) : colors,\n          stroke: colors,\n        });\n      }\n    }\n\n    labels = {};\n    fontSize = opts.text?.valueSize ?? VALUE_MAX_FONT_SIZE;\n    labelOffset = LABEL_OFFSET_MAX;\n    vSpace = hSpace = Infinity;\n  };\n\n  // uPlot hook to draw the labels on the bar chart.\n  const draw = (u: uPlot) => {\n    if (showValue === VisibilityMode.Never || fontSize < VALUE_MIN_FONT_SIZE) {\n      return;\n    }\n\n    u.ctx.save();\n    u.ctx.fillStyle = theme.colors.text.primary;\n    u.ctx.font = `${fontSize}px ${theme.typography.fontFamily}`;\n\n    let curAlign: CanvasTextAlign | undefined = undefined,\n      curBaseline: CanvasTextBaseline | undefined = undefined;\n\n    for (const didx in labels) {\n      // exclude first label from overlap testing\n      let first = true;\n\n      for (const sidx in labels[didx]) {\n        const label = labels[didx][sidx];\n        const { text, x = 0, y = 0 } = label;\n        let { value } = label;\n\n        if (opts.negY?.[sidx] && value != null) {\n          value *= -1;\n        }\n\n        let align: CanvasTextAlign = isXHorizontal ? 'center' : value !== null && value < 0 ? 'right' : 'left';\n        let baseline: CanvasTextBaseline = isXHorizontal\n          ? value !== null && value < 0\n            ? 'top'\n            : 'alphabetic'\n          : 'middle';\n\n        if (align !== curAlign) {\n          u.ctx.textAlign = curAlign = align;\n        }\n\n        if (baseline !== curBaseline) {\n          u.ctx.textBaseline = curBaseline = baseline;\n        }\n\n        if (showValue === VisibilityMode.Always) {\n          u.ctx.fillText(text, x, y);\n        } else if (showValue === VisibilityMode.Auto) {\n          let { bbox } = label;\n\n          let intersectsLabel = false;\n\n          if (bbox == null) {\n            intersectsLabel = true;\n            label.hidden = true;\n          } else if (!first) {\n            // Test for any collisions\n            for (const subsidx in labels[didx]) {\n              if (subsidx === sidx) {\n                continue;\n              }\n\n              const label2 = labels[didx][subsidx];\n              const { bbox: bbox2, hidden } = label2;\n\n              if (!hidden && bbox2 && intersects(bbox, bbox2)) {\n                intersectsLabel = true;\n                label.hidden = true;\n                break;\n              }\n            }\n          }\n\n          first = false;\n\n          !intersectsLabel && u.ctx.fillText(text, x, y);\n        }\n      }\n    }\n\n    u.ctx.restore();\n  };\n\n  let alignedTotals: AlignedData | null = null;\n\n  function prepData(frames: DataFrame[], stackingGroups: StackingGroup[]) {\n    alignedTotals = null;\n    return preparePlotData2(frames[0], stackingGroups, ({ totals }) => {\n      alignedTotals = totals;\n    });\n  }\n\n  return {\n    cursor,\n    // scale & axis opts\n    xRange,\n    xValues,\n    xSplits,\n    hFilter,\n\n    barsBuilder,\n\n    // hooks\n    init,\n    drawClear,\n    draw,\n    prepData,\n  };\n}\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip, common.OptionsWithTextFormatting {\n  /**\n   * Controls the radius of each bar.\n   */\n  barRadius?: number;\n  /**\n   * Controls the width of bars. 1 = Max width, 0 = Min width.\n   */\n  barWidth: number;\n  /**\n   * Use the color value for a sibling field to color each bar value.\n   */\n  colorByField?: string;\n  /**\n   * Enables mode which highlights the entire bar area and shows tooltip when cursor\n   * hovers over highlighted area\n   */\n  fullHighlight: boolean;\n  /**\n   * Controls the width of groups. 1 = max with, 0 = min width.\n   */\n  groupWidth: number;\n  /**\n   * Controls the orientation of the bar chart, either vertical or horizontal.\n   */\n  orientation: common.VizOrientation;\n  /**\n   * This controls whether values are shown on top or to the left of bars.\n   */\n  showValue: common.VisibilityMode;\n  /**\n   * Controls whether bars are stacked or not, either normally or in percent mode.\n   */\n  stacking: common.StackingMode;\n  /**\n   * Manually select which field from the dataset to represent the x field.\n   */\n  xField?: string;\n  /**\n   * Sets the max length that a label can have before it is truncated.\n   */\n  xTickLabelMaxLength: number;\n  /**\n   * Controls the rotation of the x axis labels.\n   */\n  xTickLabelRotation: number;\n  /**\n   * Controls the spacing between x axis labels.\n   * negative values indicate backwards skipping behavior\n   */\n  xTickLabelSpacing?: number;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  barRadius: 0,\n  barWidth: 0.97,\n  fullHighlight: false,\n  groupWidth: 0.7,\n  orientation: common.VizOrientation.Auto,\n  showValue: common.VisibilityMode.Auto,\n  stacking: common.StackingMode.None,\n  xTickLabelRotation: 0,\n  xTickLabelSpacing: 0,\n};\n\nexport interface FieldConfig extends common.AxisConfig, common.HideableFieldConfig {\n  /**\n   * Controls the fill opacity of the bars.\n   */\n  fillOpacity?: number;\n  /**\n   * Set the mode of the gradient fill. Fill gradient is based on the line color. To change the color, use the standard color scheme field option.\n   * Gradient appearance is influenced by the Fill opacity setting.\n   */\n  gradientMode?: common.GraphGradientMode;\n  /**\n   * Controls line width of the bars.\n   */\n  lineWidth?: number;\n  /**\n   * Threshold rendering\n   */\n  thresholdsStyle?: common.GraphThresholdsStyleConfig;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 80,\n  gradientMode: common.GraphGradientMode.None,\n  lineWidth: 1,\n};\n","import uPlot, { Padding } from 'uplot';\n\nimport {\n  DataFrame,\n  Field,\n  FieldConfigSource,\n  FieldType,\n  GrafanaTheme2,\n  cacheFieldDisplayNames,\n  formattedValueToString,\n  getDisplayProcessor,\n  getFieldColorModeForField,\n  getFieldSeriesColor,\n  outerJoinDataFrames,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/internal';\nimport { t } from '@grafana/i18n';\nimport {\n  AxisColorMode,\n  AxisPlacement,\n  FieldColorModeId,\n  GraphThresholdsStyleMode,\n  GraphTransform,\n  ScaleDistribution,\n  TimeZone,\n  TooltipDisplayMode,\n  VizOrientation,\n} from '@grafana/schema';\nimport {\n  FIXED_UNIT,\n  ScaleDirection,\n  ScaleOrientation,\n  StackingMode,\n  UPlotConfigBuilder,\n  measureText,\n} from '@grafana/ui';\nimport { AxisProps, UPLOT_AXIS_FONT_SIZE, getStackingGroups } from '@grafana/ui/internal';\n\nimport { setClassicPaletteIdxs } from '../timeseries/utils';\n\nimport { BarsOptions, getConfig } from './bars';\nimport { FieldConfig, Options, defaultFieldConfig } from './panelcfg.gen';\n// import { isLegendOrdered } from './utils';\n\ninterface BarSeries {\n  series: DataFrame[];\n  _rest: Field[];\n  color?: Field | null;\n  warn?: string | null;\n}\n\nexport function prepSeries(\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource,\n  stacking: StackingMode,\n  theme: GrafanaTheme2,\n  xFieldName?: string,\n  colorFieldName?: string\n): BarSeries {\n  // this allows PanelDataErrorView to show the default noValue message\n  if (frames.length === 0 || frames.every((fr) => fr.length === 0)) {\n    return {\n      warn: '',\n      series: [],\n      _rest: [],\n    };\n  }\n\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let frame: DataFrame | undefined = { ...frames[0] };\n\n  // auto-sort and/or join on first time field (if any)\n  // TODO: should this always join on the xField (if supplied?)\n  const timeFieldIdx = frame.fields.findIndex((f) => f.type === FieldType.time);\n\n  if (timeFieldIdx >= 0 && frames.length > 1) {\n    frame = outerJoinDataFrames({ frames, keepDisplayNames: true }) ?? frame;\n  }\n\n  const xField =\n    // TODO: use matcher\n    frame.fields.find((field) => field.state?.displayName === xFieldName || field.name === xFieldName) ??\n    frame.fields.find((field) => field.type === FieldType.string) ??\n    frame.fields[timeFieldIdx];\n\n  if (xField != null) {\n    const fields: Field[] = [xField];\n    const _rest: Field[] = [];\n\n    const colorField =\n      colorFieldName == null\n        ? undefined\n        : frame.fields.find(\n            // TODO: use matcher\n            (field) => field.state?.displayName === colorFieldName || field.name === colorFieldName\n          );\n\n    frame.fields.forEach((field) => {\n      if (field !== xField) {\n        if (field.type === FieldType.number && !field.config.custom?.hideFrom?.viz) {\n          const field2 = {\n            ...field,\n            values: field.values.map((v) => (Number.isFinite(v) ? v : null)),\n            // TODO: stacking should be moved from panel opts to fieldConfig (like TimeSeries) so we dont have to do this\n            config: {\n              ...field.config,\n              custom: {\n                ...field.config.custom,\n                stacking: {\n                  group: '_',\n                  mode: stacking,\n                },\n              },\n            },\n          };\n\n          fields.push(field2);\n        } else {\n          _rest.push(field);\n        }\n      }\n    });\n\n    let warn: string | null = null;\n\n    if (fields.length === 1) {\n      warn = t('bar-chart.warn.missing-numeric', 'No numeric fields found');\n    }\n\n    frame.fields = fields;\n\n    const series = [frame];\n\n    setClassicPaletteIdxs(series, theme, 0);\n\n    return {\n      series,\n      _rest,\n      color: colorField,\n      warn,\n    };\n  }\n\n  return {\n    series: [],\n    _rest: [],\n    color: null,\n    warn: t('bar-chart.warn.missing-series', 'Bar charts require a string or time field'),\n  };\n}\n\nexport interface PrepConfigOpts {\n  series: DataFrame[]; // series with hideFrom.viz: false\n  totalSeries: number; // total series count (including hidden)\n  color?: Field | null;\n  orientation: VizOrientation;\n  options: Options;\n  timeZone: TimeZone;\n  theme: GrafanaTheme2;\n}\n\nexport const prepConfig = ({ series, totalSeries, color, orientation, options, timeZone, theme }: PrepConfigOpts) => {\n  let {\n    showValue,\n    groupWidth,\n    barWidth,\n    barRadius = 0,\n    stacking,\n    text,\n    tooltip,\n    xTickLabelRotation,\n    xTickLabelMaxLength,\n    xTickLabelSpacing = 0,\n    legend,\n    fullHighlight,\n  } = options;\n  // this and color is kept up to date by returned prepData()\n  let frame = series[0];\n\n  const builder = new UPlotConfigBuilder();\n\n  const formatters = frame.fields.map((f, i) => {\n    if (stacking === StackingMode.Percent) {\n      return getDisplayProcessor({\n        field: {\n          ...f,\n          config: {\n            ...f.config,\n            unit: 'percentunit',\n          },\n        },\n        theme,\n      });\n    }\n\n    return f.display!;\n  });\n\n  const formatValue = (seriesIdx: number, value: unknown) => {\n    return formattedValueToString(formatters[seriesIdx](value));\n  };\n\n  const formatShortValue = (seriesIdx: number, value: unknown) => {\n    return shortenValue(formatValue(seriesIdx, value), xTickLabelMaxLength);\n  };\n\n  // bar orientation -> x scale orientation & direction\n  const vizOrientation = getScaleOrientation(orientation);\n\n  // Use bar width when only one field\n  if (frame.fields.length === 2 && stacking === StackingMode.None) {\n    if (totalSeries === 1) {\n      groupWidth = barWidth;\n    }\n\n    barWidth = 1;\n  }\n\n  const rawValue = (seriesIdx: number, valueIdx: number) => {\n    return frame.fields[seriesIdx].values[valueIdx];\n  };\n\n  // Color by value\n  let getColor: ((seriesIdx: number, valueIdx: number) => string) | undefined = undefined;\n\n  let fillOpacity = 1;\n\n  if (color != null) {\n    const disp = color.display!;\n    fillOpacity = (color.config.custom.fillOpacity ?? 100) / 100;\n    // gradientMode? ignore?\n    getColor = (seriesIdx: number, valueIdx: number) => disp(color!.values[valueIdx]).color!;\n  } else {\n    const hasPerBarColor = frame.fields.some((f) => {\n      const fromThresholds = f.config.color?.mode === FieldColorModeId.Thresholds;\n\n      return (\n        fromThresholds ||\n        f.config.mappings?.some((m) => {\n          // ValueToText mappings have a different format, where all of them are grouped into an object keyed by value\n          if (m.type === 'value') {\n            // === MappingType.ValueToText\n            return Object.values(m.options).some((result) => result.color != null);\n          }\n          return m.options.result.color != null;\n        })\n      );\n    });\n\n    if (hasPerBarColor) {\n      // use opacity from first numeric field\n      let opacityField = frame.fields.find((f) => f.type === FieldType.number)!;\n\n      fillOpacity = (opacityField?.config?.custom?.fillOpacity ?? 100) / 100;\n\n      getColor = (seriesIdx: number, valueIdx: number) => {\n        let field = frame.fields[seriesIdx];\n        return field.display!(field.values[valueIdx]).color!;\n      };\n    }\n  }\n\n  const opts: BarsOptions = {\n    xOri: vizOrientation.xOri,\n    xDir: vizOrientation.xDir,\n    groupWidth,\n    barWidth,\n    barRadius,\n    stacking,\n    rawValue,\n    getColor,\n    fillOpacity,\n    formatValue,\n    formatShortValue,\n    timeZone,\n    text,\n    showValue,\n    legend,\n    xSpacing: xTickLabelSpacing,\n    xTimeAuto: frame.fields[0]?.type === FieldType.time && !frame.fields[0].config.unit?.startsWith('time:'),\n    negY: frame.fields.map((f) => f.config.custom?.transform === GraphTransform.NegativeY),\n    fullHighlight,\n    hoverMulti: tooltip.mode === TooltipDisplayMode.Multi,\n  };\n\n  const config = getConfig(opts, theme);\n\n  builder.setCursor(config.cursor);\n\n  builder.addHook('init', config.init);\n  builder.addHook('drawClear', config.drawClear);\n  builder.addHook('draw', config.draw);\n\n  if (xTickLabelRotation !== 0) {\n    // these are the amount of space we already have available between plot edge and first label\n    // TODO: removing these hardcoded value requires reading back uplot instance props\n    let lftSpace = 50;\n    let btmSpace = vizOrientation.xOri === ScaleOrientation.Horizontal ? 14 : 5;\n\n    builder.setPadding(getRotationPadding(frame, xTickLabelRotation, xTickLabelMaxLength, lftSpace, btmSpace));\n  }\n\n  builder.setPrepData(config.prepData);\n\n  builder.addScale({\n    scaleKey: 'x',\n    isTime: false,\n    range: config.xRange,\n    distribution: ScaleDistribution.Ordinal,\n    orientation: vizOrientation.xOri,\n    direction: vizOrientation.xDir,\n  });\n\n  const xFieldAxisPlacement =\n    frame.fields[0]?.config.custom?.axisPlacement !== AxisPlacement.Hidden\n      ? vizOrientation.xOri === ScaleOrientation.Horizontal\n        ? AxisPlacement.Bottom\n        : AxisPlacement.Left\n      : AxisPlacement.Hidden;\n  const xFieldAxisShow = frame.fields[0]?.config.custom?.axisPlacement !== AxisPlacement.Hidden;\n\n  builder.addAxis({\n    scaleKey: 'x',\n    isTime: false,\n    placement: xFieldAxisPlacement,\n    label: frame.fields[0]?.config.custom?.axisLabel,\n    splits: config.xSplits,\n    filter: vizOrientation.xOri === 0 ? config.hFilter : undefined,\n    values: config.xValues,\n    timeZone,\n    grid: { show: false },\n    ticks: { show: false },\n    gap: 15,\n    tickLabelRotation: vizOrientation.xOri === 0 ? xTickLabelRotation * -1 : 0,\n    theme,\n    show: xFieldAxisShow,\n  });\n\n  // let seriesIndex = 0;\n  // const legendOrdered = isLegendOrdered(legend);\n\n  // iterate the y values\n  for (let i = 1; i < frame.fields.length; i++) {\n    const field = frame.fields[i];\n\n    // seriesIndex++;\n\n    const customConfig: FieldConfig = { ...defaultFieldConfig, ...field.config.custom };\n\n    const scaleKey = field.config.unit || FIXED_UNIT;\n    const colorMode = getFieldColorModeForField(field);\n    const scaleColor = getFieldSeriesColor(field, theme);\n    const seriesColor = scaleColor.color;\n\n    // make barcharts start at 0 unless explicitly overridden\n    let softMin = customConfig.axisSoftMin;\n    let softMax = customConfig.axisSoftMax;\n\n    if (softMin == null && field.config.min == null) {\n      softMin = 0;\n    }\n\n    if (softMax == null && field.config.max == null) {\n      softMax = 0;\n    }\n\n    // Render thresholds in graph\n    if (customConfig.thresholdsStyle && field.config.thresholds) {\n      const thresholdDisplay = customConfig.thresholdsStyle.mode ?? GraphThresholdsStyleMode.Off;\n      if (thresholdDisplay !== GraphThresholdsStyleMode.Off) {\n        builder.addThresholds({\n          config: customConfig.thresholdsStyle,\n          thresholds: field.config.thresholds,\n          scaleKey,\n          theme,\n          hardMin: field.config.min,\n          hardMax: field.config.max,\n          softMin: customConfig.axisSoftMin,\n          softMax: customConfig.axisSoftMax,\n        });\n      }\n    }\n\n    builder.addSeries({\n      scaleKey,\n      pxAlign: true,\n      lineWidth: customConfig.lineWidth,\n      lineColor: seriesColor,\n      fillOpacity: customConfig.fillOpacity,\n      theme,\n      colorMode,\n      pathBuilder: config.barsBuilder,\n      show: !customConfig.hideFrom?.viz,\n      gradientMode: customConfig.gradientMode,\n      thresholds: field.config.thresholds,\n      hardMin: field.config.min,\n      hardMax: field.config.max,\n      softMin: customConfig.axisSoftMin,\n      softMax: customConfig.axisSoftMax,\n\n      // The following properties are not used in the uPlot config, but are utilized as transport for legend config\n      // PlotLegend currently gets unfiltered DataFrame[], so index must be into that field array, not the prepped frame's which we're iterating here\n      // dataFrameFieldIndex: {\n      //   fieldIndex: legendOrdered\n      //     ? i\n      //     : allFrames[0].fields.findIndex(\n      //         (f) => f.type === FieldType.number && f.state?.seriesIndex === seriesIndex - 1\n      //       ),\n      //   frameIndex: 0,\n      // },\n    });\n\n    // The builder will manage unique scaleKeys and combine where appropriate\n    builder.addScale({\n      scaleKey,\n      min: field.config.min,\n      max: field.config.max,\n      softMin,\n      softMax,\n      centeredZero: customConfig.axisCenteredZero,\n      orientation: vizOrientation.yOri,\n      direction: vizOrientation.yDir,\n      distribution: customConfig.scaleDistribution?.type,\n      log: customConfig.scaleDistribution?.log,\n      decimals: field.config.decimals,\n    });\n\n    if (customConfig.axisPlacement !== AxisPlacement.Hidden) {\n      let placement = customConfig.axisPlacement;\n      if (!placement || placement === AxisPlacement.Auto) {\n        placement = AxisPlacement.Left;\n      }\n      if (vizOrientation.xOri === 1) {\n        if (placement === AxisPlacement.Left) {\n          placement = AxisPlacement.Bottom;\n        }\n        if (placement === AxisPlacement.Right) {\n          placement = AxisPlacement.Top;\n        }\n      }\n\n      let axisOpts: AxisProps = {\n        scaleKey,\n        label: customConfig.axisLabel,\n        size: customConfig.axisWidth,\n        placement,\n        formatValue: (v, decimals) => formattedValueToString(field.display!(v, decimals)),\n        filter: vizOrientation.yOri === 0 ? config.hFilter : undefined,\n        tickLabelRotation: vizOrientation.xOri === 1 ? xTickLabelRotation * -1 : 0,\n        theme,\n        grid: { show: customConfig.axisGridShow },\n        decimals: field.config.decimals,\n      };\n\n      if (customConfig.axisBorderShow) {\n        axisOpts.border = {\n          show: true,\n        };\n      }\n\n      if (customConfig.axisColorMode === AxisColorMode.Series) {\n        axisOpts.color = seriesColor;\n      }\n\n      builder.addAxis(axisOpts);\n    }\n  }\n\n  let stackingGroups = getStackingGroups(frame);\n\n  builder.setStackingGroups(stackingGroups);\n\n  return {\n    builder,\n    prepData: (_series: DataFrame[], _color?: Field | null) => {\n      series = _series;\n      frame = series[0];\n      color = _color;\n\n      return builder.prepData!(series);\n    },\n  };\n};\n\nfunction shortenValue(value: string, length: number) {\n  if (value.length > length) {\n    return value.substring(0, length).concat('...');\n  } else {\n    return value;\n  }\n}\n\nfunction getRotationPadding(\n  frame: DataFrame,\n  rotateLabel: number,\n  valueMaxLength: number,\n  lftSpace = 0,\n  btmSpace = 0\n): Padding {\n  const values = frame.fields[0].values;\n  const fontSize = UPLOT_AXIS_FONT_SIZE;\n  const displayProcessor = frame.fields[0].display;\n  const getProcessedValue = (i: number) => {\n    return displayProcessor ? displayProcessor(values[i]) : values[i];\n  };\n  let maxLength = 0;\n  for (let i = 0; i < values.length; i++) {\n    let size = measureText(shortenValue(formattedValueToString(getProcessedValue(i)), valueMaxLength), fontSize);\n    maxLength = size.width > maxLength ? size.width : maxLength;\n  }\n\n  // Add padding to the right if the labels are rotated in a way that makes the last label extend outside the graph.\n  const paddingRight =\n    rotateLabel > 0\n      ? Math.cos((rotateLabel * Math.PI) / 180) *\n        measureText(\n          shortenValue(formattedValueToString(getProcessedValue(values.length - 1)), valueMaxLength),\n          fontSize\n        ).width\n      : 0;\n\n  // Add padding to the left if the labels are rotated in a way that makes the first label extend outside the graph.\n  const paddingLeft =\n    rotateLabel < 0\n      ? Math.cos((rotateLabel * -1 * Math.PI) / 180) *\n        measureText(shortenValue(formattedValueToString(getProcessedValue(0)), valueMaxLength), fontSize).width\n      : 0;\n\n  // Add padding to the bottom to avoid clipping the rotated labels.\n  const paddingBottom =\n    Math.sin(((rotateLabel >= 0 ? rotateLabel : rotateLabel * -1) * Math.PI) / 180) * maxLength - btmSpace;\n\n  return [\n    Math.round(UPLOT_AXIS_FONT_SIZE * uPlot.pxRatio),\n    paddingRight,\n    paddingBottom,\n    Math.max(0, paddingLeft - lftSpace),\n  ];\n}\n\nfunction getScaleOrientation(orientation: VizOrientation) {\n  if (orientation === VizOrientation.Vertical) {\n    return {\n      xOri: ScaleOrientation.Horizontal,\n      xDir: ScaleDirection.Right,\n      yOri: ScaleOrientation.Vertical,\n      yDir: ScaleDirection.Up,\n    };\n  }\n\n  return {\n    xOri: ScaleOrientation.Vertical,\n    xDir: ScaleDirection.Down,\n    yOri: ScaleOrientation.Horizontal,\n    yDir: ScaleDirection.Right,\n  };\n}\n","import { useMemo } from 'react';\n\nimport { PanelProps, VizOrientation } from '@grafana/data';\nimport { PanelDataErrorView } from '@grafana/runtime';\nimport {\n  TooltipDisplayMode,\n  TooltipPlugin2,\n  UPLOT_AXIS_FONT_SIZE,\n  UPlotChart,\n  VizLayout,\n  measureText,\n  // usePanelContext,\n  useTheme2,\n} from '@grafana/ui';\nimport { TooltipHoverMode } from '@grafana/ui/internal';\n\nimport { TimeSeriesTooltip } from '../timeseries/TimeSeriesTooltip';\n\nimport { BarChartLegend, hasVisibleLegendSeries } from './BarChartLegend';\nimport { Options } from './panelcfg.gen';\nimport { prepConfig, prepSeries } from './utils';\n\nconst charWidth = measureText('M', UPLOT_AXIS_FONT_SIZE).width;\nconst toRads = Math.PI / 180;\n\nexport const BarChartPanel = (props: PanelProps<Options>) => {\n  const { data, options, fieldConfig, width, height, timeZone, id, replaceVariables } = props;\n\n  // will need this if joining on time to re-create data links\n  // const { dataLinkPostProcessor } = usePanelContext();\n\n  const theme = useTheme2();\n\n  const {\n    barWidth,\n    barRadius = 0,\n    showValue,\n    groupWidth,\n    stacking,\n    legend,\n    tooltip,\n    text,\n    xTickLabelRotation,\n    xTickLabelSpacing,\n    fullHighlight,\n    xField,\n    colorByField,\n  } = options;\n\n  // size-dependent, calculated opts that should cause viz re-config\n  let { orientation, xTickLabelMaxLength = 0 } = options;\n\n  orientation =\n    orientation === VizOrientation.Auto\n      ? width < height\n        ? VizOrientation.Horizontal\n        : VizOrientation.Vertical\n      : orientation;\n\n  // TODO: this can be moved into axis calc internally, no need to re-config based on this\n  // should be based on vizHeight, not full height?\n  xTickLabelMaxLength =\n    xTickLabelRotation === 0\n      ? Infinity // should this calc using spacing between groups?\n      : xTickLabelMaxLength ||\n        // auto max length clamps to half viz height, subracts 3 chars for ... ellipsis\n        Math.floor(height / 2 / Math.sin(Math.abs(xTickLabelRotation * toRads)) / charWidth - 3);\n\n  // TODO: config data links\n  const info = useMemo(\n    () => prepSeries(data.series, fieldConfig, stacking, theme, xField, colorByField),\n    [data.series, fieldConfig, stacking, theme, xField, colorByField]\n  );\n\n  const vizSeries = useMemo(\n    () =>\n      info.series.map((frame) => ({\n        ...frame,\n        fields: frame.fields.filter((field, i) => i === 0 || !field.state?.hideFrom?.viz),\n      })),\n    [info.series]\n  );\n\n  const xGroupsCount = vizSeries[0]?.length ?? 0;\n  const seriesCount = vizSeries[0]?.fields.length ?? 0;\n  const totalSeries = Math.max(0, (info.series[0]?.fields.length ?? 0) - 1);\n\n  let { builder, prepData } = useMemo(\n    () => {\n      return xGroupsCount === 0\n        ? { builder: null, prepData: null }\n        : prepConfig({ series: vizSeries, totalSeries, color: info.color, orientation, options, timeZone, theme });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      orientation,\n      timeZone,\n      props.data.structureRev,\n\n      totalSeries,\n      seriesCount,\n      xGroupsCount,\n\n      barWidth,\n      barRadius,\n      showValue,\n      groupWidth,\n      stacking,\n      legend,\n      tooltip,\n      text?.valueSize, // cause text obj is re-created each time?\n      xTickLabelRotation,\n      xTickLabelSpacing,\n      fullHighlight,\n      xField,\n      colorByField,\n      xTickLabelMaxLength, // maybe not?\n      // props.fieldConfig, // usePrevious hideFrom on all fields?\n    ]\n  );\n\n  const plotData = useMemo(\n    () => (prepData == null ? [] : prepData(vizSeries, info.color)),\n    [prepData, vizSeries, info.color]\n  );\n\n  if (info.warn != null || builder == null) {\n    return (\n      <PanelDataErrorView\n        panelId={id}\n        fieldConfig={fieldConfig}\n        data={data}\n        message={info.warn ?? ''}\n        needsNumberField={true}\n      />\n    );\n  }\n\n  const legendComp =\n    legend.showLegend && hasVisibleLegendSeries(builder, info.series!) ? (\n      <BarChartLegend data={info.series!} colorField={info.color} {...legend} />\n    ) : null;\n\n  return (\n    <VizLayout\n      width={props.width}\n      height={props.height}\n      // legend={<BarChartLegend frame={info.series![0]} colorField={info.color} {...legend} />}\n      legend={legendComp}\n    >\n      {(vizWidth, vizHeight) => (\n        <UPlotChart config={builder!} data={plotData} width={vizWidth} height={vizHeight}>\n          {props.options.tooltip.mode !== TooltipDisplayMode.None && (\n            <TooltipPlugin2\n              config={builder}\n              maxWidth={options.tooltip.maxWidth}\n              hoverMode={\n                options.tooltip.mode === TooltipDisplayMode.Single ? TooltipHoverMode.xOne : TooltipHoverMode.xAll\n              }\n              getDataLinks={(seriesIdx, dataIdx) =>\n                vizSeries[0].fields[seriesIdx].getLinks?.({ valueRowIndex: dataIdx }) ?? []\n              }\n              render={(u, dataIdxs, seriesIdx, isPinned, dismiss, timeRange2, viaSync, dataLinks) => {\n                return (\n                  <TimeSeriesTooltip\n                    series={vizSeries[0]}\n                    _rest={info._rest}\n                    dataIdxs={dataIdxs}\n                    seriesIdx={seriesIdx}\n                    mode={options.tooltip.mode}\n                    sortOrder={options.tooltip.sort}\n                    isPinned={isPinned}\n                    maxHeight={options.tooltip.maxHeight}\n                    replaceVariables={replaceVariables}\n                    dataLinks={dataLinks}\n                    hideZeros={options.tooltip.hideZeros}\n                  />\n                );\n              }}\n            />\n          )}\n        </UPlotChart>\n      )}\n    </VizLayout>\n  );\n};\n","import { SelectableValue, StandardEditorProps } from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { Checkbox, HorizontalGroup, RadioButtonGroup, Tooltip } from '@grafana/ui';\n\nexport const TickSpacingEditor = (props: StandardEditorProps<number>) => {\n  const GAPS_OPTIONS: Array<SelectableValue<number>> = [\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-none', 'None'),\n      value: 0,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-none', 'Show all tick marks'),\n    },\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-small', 'Small'),\n      value: 100,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-small', 'Require {{spacing}} spacing', {\n        spacing: '100px',\n      }),\n    },\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-medium', 'Medium'),\n      value: 200,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-medium', 'Require {{spacing}} spacing', {\n        spacing: '200px',\n      }),\n    },\n    {\n      label: t('barchart.tick-spacing-editor.gaps-options.label-large', 'Large'),\n      value: 300,\n      description: t('barchart.tick-spacing-editor.gaps-options.description-large', 'Require {{spacing}} spacing', {\n        spacing: '300px',\n      }),\n    },\n  ];\n  let value = props.value ?? 0;\n  const isRTL = value < 0;\n  if (isRTL) {\n    value *= -1;\n  }\n  let gap = GAPS_OPTIONS[0];\n  for (const v of GAPS_OPTIONS) {\n    gap = v;\n    if (value <= gap.value!) {\n      break;\n    }\n  }\n\n  const onSpacingChange = (val: number) => {\n    props.onChange(val * (isRTL ? -1 : 1));\n  };\n\n  const onRTLChange = () => {\n    props.onChange(props.value * -1);\n  };\n\n  return (\n    <HorizontalGroup>\n      <RadioButtonGroup value={gap.value} options={GAPS_OPTIONS} onChange={onSpacingChange} />\n      {value !== 0 && (\n        <Tooltip\n          content={t(\n            'barchart.tick-spacing-editor.content-require-space-from-the-right-side',\n            'Require space from the right side'\n          )}\n          placement=\"top\"\n        >\n          <div>\n            <Checkbox value={isRTL} onChange={onRTLChange} label={t('barchart.tick-spacing-editor.label-rtl', 'RTL')} />\n          </div>\n        </Tooltip>\n      )}\n    </HorizontalGroup>\n  );\n};\n","import { FieldMatcherID, PanelTypeChangedHandler, ReducerID } from '@grafana/data';\nimport { AxisPlacement } from '@grafana/ui';\n\n/*\n * This is called when the panel changes from another panel\n */\nexport const changeToBarChartPanelMigrationHandler: PanelTypeChangedHandler = (panel, prevPluginId, prevOptions) => {\n  if (prevPluginId === 'graph') {\n    const graphOptions: GraphOptions = prevOptions.angular;\n\n    const fieldConfig = panel.fieldConfig ?? { defaults: {}, overrides: [] };\n\n    if (graphOptions.xaxis?.mode === 'series') {\n      const transformations = panel.transformations || [];\n      transformations.push(\n        {\n          id: 'reduce',\n          options: {\n            reducers: getReducer(graphOptions.xaxis?.values),\n          },\n        },\n        {\n          id: 'transpose',\n          options: {},\n        }\n      );\n\n      panel.transformations = transformations;\n\n      // temporary, until we have a bar chart with per bar labels\n      fieldConfig.overrides.push({\n        matcher: {\n          id: FieldMatcherID.byName,\n          options: 'Field',\n        },\n        properties: [\n          {\n            id: 'custom.axisPlacement',\n            value: AxisPlacement.Hidden,\n          },\n        ],\n      });\n\n      panel.fieldConfig = fieldConfig;\n      panel.options = {\n        ...panel.options,\n        groupWidth: 1,\n      };\n    }\n  }\n\n  return {};\n};\n\n// same as grafana-ui/src/components/SingleStatShared/SingleStatBaseOptions.ts\nconst getReducer = (reducers: string[] | undefined) => {\n  const transformReducers: string[] = [];\n\n  reducers?.forEach((reducer) => {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    if (!Object.values(ReducerID).includes(reducer as ReducerID)) {\n      if (reducer === 'current') {\n        transformReducers.push(ReducerID.lastNotNull);\n      } else if (reducer === 'total') {\n        transformReducers.push(ReducerID.sum);\n      } else if (reducer === 'avg') {\n        transformReducers.push(ReducerID.mean);\n      }\n    } else {\n      transformReducers.push(reducer);\n    }\n  });\n\n  return reducers ? transformReducers : [ReducerID.sum];\n};\n\ninterface GraphOptions {\n  xaxis: {\n    mode: 'series' | 'time' | 'histogram';\n    values?: string[];\n  };\n}\n","import { VisualizationSuggestionsBuilder, VizOrientation } from '@grafana/data';\nimport { LegendDisplayMode, StackingMode, VisibilityMode } from '@grafana/schema';\nimport { SuggestionName } from 'app/types/suggestions';\n\nimport { FieldConfig, Options } from './panelcfg.gen';\n\nexport class BarChartSuggestionsSupplier {\n  getListWithDefaults(builder: VisualizationSuggestionsBuilder) {\n    return builder.getListAppender<Options, FieldConfig>({\n      name: SuggestionName.BarChart,\n      pluginId: 'barchart',\n      options: {\n        showValue: VisibilityMode.Never,\n        legend: {\n          calcs: [],\n          displayMode: LegendDisplayMode.List,\n          showLegend: true,\n          placement: 'right',\n        },\n      },\n      fieldConfig: {\n        defaults: {\n          unit: 'short',\n          custom: {},\n        },\n        overrides: [],\n      },\n      cardOptions: {\n        previewModifier: (s) => {\n          s.options!.barWidth = 0.8;\n        },\n      },\n    });\n  }\n\n  getSuggestionsForData(builder: VisualizationSuggestionsBuilder) {\n    const list = this.getListWithDefaults(builder);\n    const { dataSummary } = builder;\n\n    if (dataSummary.frameCount !== 1) {\n      return;\n    }\n\n    if (!dataSummary.hasNumberField || !dataSummary.hasStringField) {\n      return;\n    }\n\n    // if you have this many rows barchart might not be a good fit\n    if (dataSummary.rowCountTotal > 50) {\n      return;\n    }\n\n    // Vertical bars\n    list.append({\n      name: SuggestionName.BarChart,\n    });\n\n    if (dataSummary.numberFieldCount > 1) {\n      list.append({\n        name: SuggestionName.BarChartStacked,\n        options: {\n          stacking: StackingMode.Normal,\n        },\n      });\n      list.append({\n        name: SuggestionName.BarChartStackedPercent,\n        options: {\n          stacking: StackingMode.Percent,\n        },\n      });\n    }\n\n    // horizontal bars\n    list.append({\n      name: SuggestionName.BarChartHorizontal,\n      options: {\n        orientation: VizOrientation.Horizontal,\n      },\n    });\n\n    if (dataSummary.numberFieldCount > 1) {\n      list.append({\n        name: SuggestionName.BarChartHorizontalStacked,\n        options: {\n          stacking: StackingMode.Normal,\n          orientation: VizOrientation.Horizontal,\n        },\n      });\n\n      list.append({\n        name: SuggestionName.BarChartHorizontalStackedPercent,\n        options: {\n          orientation: VizOrientation.Horizontal,\n          stacking: StackingMode.Percent,\n        },\n      });\n    }\n  }\n}\n","import {\n  DataFrame,\n  FieldColorModeId,\n  FieldConfigProperty,\n  FieldType,\n  identityOverrideProcessor,\n  PanelPlugin,\n  VizOrientation,\n} from '@grafana/data';\nimport { t } from '@grafana/i18n';\nimport { GraphTransform, GraphThresholdsStyleMode, StackingMode, VisibilityMode } from '@grafana/schema';\nimport { getGraphFieldOptions, commonOptionsBuilder } from '@grafana/ui';\nimport { optsWithHideZeros } from '@grafana/ui/internal';\n\nimport { ThresholdsStyleEditor } from '../timeseries/ThresholdsStyleEditor';\n\nimport { BarChartPanel } from './BarChartPanel';\nimport { TickSpacingEditor } from './TickSpacingEditor';\nimport { changeToBarChartPanelMigrationHandler } from './migrations';\nimport { FieldConfig, Options, defaultFieldConfig, defaultOptions } from './panelcfg.gen';\nimport { BarChartSuggestionsSupplier } from './suggestions';\n\nexport const plugin = new PanelPlugin<Options, FieldConfig>(BarChartPanel)\n  .setPanelChangeHandler(changeToBarChartPanelMigrationHandler)\n  .useFieldConfig({\n    standardOptions: {\n      [FieldConfigProperty.Color]: {\n        settings: {\n          byValueSupport: true,\n          preferThresholdsMode: false,\n        },\n        defaultValue: {\n          mode: FieldColorModeId.PaletteClassic,\n        },\n      },\n      [FieldConfigProperty.Links]: {\n        settings: {\n          showOneClick: true,\n        },\n      },\n      [FieldConfigProperty.Actions]: {\n        hideFromDefaults: false,\n      },\n    },\n    useCustomConfig: (builder) => {\n      const cfg = defaultFieldConfig;\n\n      builder\n        .addSliderInput({\n          path: 'lineWidth',\n          name: t('barchart.config.name-line-width', 'Line width'),\n          defaultValue: cfg.lineWidth,\n          settings: {\n            min: 0,\n            max: 10,\n            step: 1,\n          },\n        })\n        .addSliderInput({\n          path: 'fillOpacity',\n          name: t('barchart.config.name-fill-opacity', 'Fill opacity'),\n          defaultValue: cfg.fillOpacity,\n          settings: {\n            min: 0,\n            max: 100,\n            step: 1,\n          },\n        })\n        .addRadio({\n          path: 'gradientMode',\n          name: t('barchart.config.name-gradient-mode', 'Gradient mode'),\n          defaultValue: getGraphFieldOptions().fillGradient[0].value,\n          settings: {\n            options: getGraphFieldOptions().fillGradient,\n          },\n        });\n\n      builder.addSelect({\n        category: ['Graph styles'],\n        name: t('barchart.config.name-transform', 'Transform'),\n        path: 'transform',\n        settings: {\n          options: [\n            {\n              label: t('barchart.config.transform-options.label-constant', 'Constant'),\n              value: GraphTransform.Constant,\n              description: t(\n                'barchart.config.transform-options.description-constant',\n                'The first value will be shown as a constant line'\n              ),\n            },\n            {\n              label: t('barchart.config.transform-options.label-negative-y', 'Negative Y'),\n              value: GraphTransform.NegativeY,\n              description: t(\n                'barchart.config.transform-options.description-negative-y',\n                'Flip the results to negative values on the y axis'\n              ),\n            },\n          ],\n          isClearable: true,\n        },\n        hideFromDefaults: true,\n      });\n\n      builder.addCustomEditor({\n        id: 'thresholdsStyle',\n        path: 'thresholdsStyle',\n        name: t('barchart.config.name-show-thresholds', 'Show thresholds'),\n        category: [t('barchart.config.category-thresholds', 'Thresholds')],\n        defaultValue: { mode: GraphThresholdsStyleMode.Off },\n        settings: {\n          options: getGraphFieldOptions().thresholdsDisplayModes,\n        },\n        editor: ThresholdsStyleEditor,\n        override: ThresholdsStyleEditor,\n        process: identityOverrideProcessor,\n        shouldApply: () => true,\n      });\n\n      commonOptionsBuilder.addAxisConfig(builder, cfg);\n      commonOptionsBuilder.addHideFrom(builder);\n    },\n  })\n  .setPanelOptions((builder) => {\n    builder\n      .addFieldNamePicker({\n        path: 'xField',\n        name: t('barchart.config.name-x-axis', 'X Axis'),\n        settings: {\n          placeholderText: t('barchart.config.placeholder-x-axis', 'First string or time field'),\n        },\n      })\n      .addRadio({\n        path: 'orientation',\n        name: t('barchart.config.name-orientation', 'Orientation'),\n        settings: {\n          options: [\n            { value: VizOrientation.Auto, label: t('barchart.config.orientation-options.label-auto', 'Auto') },\n            {\n              value: VizOrientation.Horizontal,\n              label: t('barchart.config.orientation-options.label-horizontal', 'Horizontal'),\n            },\n            {\n              value: VizOrientation.Vertical,\n              label: t('barchart.config.orientation-options.label-line-vertical', 'Vertical'),\n            },\n          ],\n        },\n        defaultValue: defaultOptions.orientation,\n      })\n      .addSliderInput({\n        path: 'xTickLabelRotation',\n        name: t('barchart.config.name-rotate-x-labels', 'Rotate x-axis tick labels'),\n        defaultValue: defaultOptions.xTickLabelRotation,\n        settings: {\n          min: -90,\n          max: 90,\n          step: 15,\n          marks: { '-90': '-90', '-45': '-45', 0: '0', 45: '45', 90: '90' },\n          included: false,\n        },\n      })\n      .addNumberInput({\n        path: 'xTickLabelMaxLength',\n        name: t('barchart.config.name-x-label-max-length', 'X-axis tick label max length'),\n        description: t(\n          'barchart.config.description-x-label-max-length',\n          'X-axis labels will be truncated to the length provided'\n        ),\n        settings: {\n          placeholder: t('barchart.config.placeholder-x-label-max-length', 'None'),\n          min: 0,\n        },\n        showIf: (opts) => opts.xTickLabelRotation !== 0,\n      })\n      .addCustomEditor({\n        id: 'xTickLabelSpacing',\n        path: 'xTickLabelSpacing',\n        name: t('barchart.config.name-x-label-min-spacing', 'X-axis labels minimum spacing'),\n        defaultValue: defaultOptions.xTickLabelSpacing,\n        editor: TickSpacingEditor,\n      })\n      .addRadio({\n        path: 'showValue',\n        name: t('barchart.config.name-show-values', 'Show values'),\n        settings: {\n          options: [\n            { value: VisibilityMode.Auto, label: t('barchart.config.show-values-options.label-auto', 'Auto') },\n            { value: VisibilityMode.Always, label: t('barchart.config.show-values-options.label-always', 'Always') },\n            { value: VisibilityMode.Never, label: t('barchart.config.show-values-options.label-never', 'Never') },\n          ],\n        },\n        defaultValue: defaultOptions.showValue,\n      })\n      .addRadio({\n        path: 'stacking',\n        name: t('barchart.config.name-stacking', 'Stacking'),\n        settings: {\n          options: getGraphFieldOptions().stacking,\n        },\n        defaultValue: defaultOptions.stacking,\n      })\n      .addSliderInput({\n        path: 'groupWidth',\n        name: t('barchart.config.name-group-width', 'Group width'),\n        defaultValue: defaultOptions.groupWidth,\n        settings: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n        showIf: (c, data) => {\n          if (c.stacking && c.stacking !== StackingMode.None) {\n            return false;\n          }\n          return countNumberFields(data) !== 1;\n        },\n      })\n      .addSliderInput({\n        path: 'barWidth',\n        name: t('barchart.config.name-bar-width', 'Bar width'),\n        defaultValue: defaultOptions.barWidth,\n        settings: {\n          min: 0,\n          max: 1,\n          step: 0.01,\n        },\n      })\n      .addSliderInput({\n        path: 'barRadius',\n        name: t('barchart.config.name-bar-radius', 'Bar radius'),\n        defaultValue: defaultOptions.barRadius,\n        settings: {\n          min: 0,\n          max: 0.5,\n          step: 0.05,\n        },\n      })\n      .addBooleanSwitch({\n        path: 'fullHighlight',\n        name: t('barchart.config.name-full-highlight', 'Highlight full area on hover'),\n        defaultValue: defaultOptions.fullHighlight,\n        showIf: (c) => c.stacking === StackingMode.None,\n      });\n\n    builder.addFieldNamePicker({\n      path: 'colorByField',\n      name: t('barchart.config.name-color-by-field', 'Color by field'),\n      description: t(\n        'barchart.config.description-color-by-field',\n        'Use the color value for a sibling field to color each bar value.'\n      ),\n    });\n\n    commonOptionsBuilder.addTooltipOptions(builder, false, false, optsWithHideZeros);\n    commonOptionsBuilder.addLegendOptions(builder);\n    commonOptionsBuilder.addTextSizeOptions(builder, false);\n  })\n  .setSuggestionsSupplier(new BarChartSuggestionsSupplier());\n\nfunction countNumberFields(data?: DataFrame[]): number {\n  let count = 0;\n  if (data) {\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        if (field.type === FieldType.number) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as ui from '@grafana/schema';\n\nexport enum HorizontalConstraint {\n  Center = 'center',\n  Left = 'left',\n  LeftRight = 'leftright',\n  Right = 'right',\n  Scale = 'scale',\n}\n\nexport enum VerticalConstraint {\n  Bottom = 'bottom',\n  Center = 'center',\n  Scale = 'scale',\n  Top = 'top',\n  TopBottom = 'topbottom',\n}\n\nexport interface Constraint {\n  horizontal?: HorizontalConstraint;\n  vertical?: VerticalConstraint;\n}\n\nexport interface Placement {\n  bottom?: number;\n  height?: number;\n  left?: number;\n  right?: number;\n  rotation?: number;\n  top?: number;\n  width?: number;\n}\n\nexport enum BackgroundImageSize {\n  Contain = 'contain',\n  Cover = 'cover',\n  Fill = 'fill',\n  Original = 'original',\n  Tile = 'tile',\n}\n\nexport interface BackgroundConfig {\n  color?: ui.ColorDimensionConfig;\n  image?: ui.ResourceDimensionConfig;\n  size?: BackgroundImageSize;\n}\n\nexport interface LineConfig {\n  color?: ui.ColorDimensionConfig;\n  radius?: number;\n  width?: number;\n}\n\nexport enum HttpRequestMethod {\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n}\n\nexport interface ConnectionCoordinates {\n  x: number;\n  y: number;\n}\n\nexport enum ConnectionPath {\n  Straight = 'straight',\n}\n\nexport interface CanvasConnection {\n  color?: ui.ColorDimensionConfig;\n  path: ConnectionPath;\n  size?: ui.ScaleDimensionConfig;\n  source: ConnectionCoordinates;\n  sourceOriginal?: ConnectionCoordinates;\n  target: ConnectionCoordinates;\n  targetName?: string;\n  targetOriginal?: ConnectionCoordinates;\n  vertices?: Array<ConnectionCoordinates>;\n}\n\nexport const defaultCanvasConnection: Partial<CanvasConnection> = {\n  vertices: [],\n};\n\nexport interface CanvasElementOptions {\n  background?: BackgroundConfig;\n  border?: LineConfig;\n  /**\n   * TODO: figure out how to define this (element config(s))\n   */\n  config?: unknown;\n  connections?: Array<CanvasConnection>;\n  constraint?: Constraint;\n  name: string;\n  placement?: Placement;\n  type: string;\n}\n\nexport const defaultCanvasElementOptions: Partial<CanvasElementOptions> = {\n  connections: [],\n};\n\nexport interface Options {\n  /**\n   * Enable infinite pan\n   */\n  infinitePan: boolean;\n  /**\n   * Enable inline editing\n   */\n  inlineEditing: boolean;\n  /**\n   * Enable pan and zoom\n   */\n  panZoom: boolean;\n  /**\n   * The root element of canvas (frame), where all canvas elements are nested\n   * TODO: Figure out how to define a default value for this\n   */\n  root: {\n    /**\n     * Name of the root element\n     */\n    name: string;\n    /**\n     * Type of root element (frame)\n     */\n    type: 'frame';\n    /**\n     * The list of canvas elements attached to the root element\n     */\n    elements: Array<CanvasElementOptions>;\n  };\n  /**\n   * Show all available element types\n   */\n  showAdvancedTypes: boolean;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  infinitePan: true,\n  inlineEditing: true,\n  panZoom: true,\n  showAdvancedTypes: true,\n};\n","import { DataFrame, ActionModel, Field, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { getActions } from 'app/features/actions/utils';\n\nexport const getDataLinks = (field: Field, rowIdx: number) => {\n  const links: Array<LinkModel<Field>> = [];\n\n  if ((field.config.links?.length ?? 0) > 0 && field.getLinks != null) {\n    const v = field.values[rowIdx];\n    const disp = field.display ? field.display(v) : { text: `${v}`, numeric: +v };\n\n    const linkLookup = new Set<string>();\n\n    field.getLinks({ calculatedValue: disp, valueRowIndex: rowIdx }).forEach((link) => {\n      const key = `${link.title}/${link.href}`;\n      if (!linkLookup.has(key)) {\n        links.push(link);\n        linkLookup.add(key);\n      }\n    });\n  }\n\n  return links;\n};\n\nexport const getAllFrameActions = (dataFrame: DataFrame) => {};\n\nexport const getFieldActions = (\n  dataFrame: DataFrame,\n  field: Field,\n  replaceVars: InterpolateFunction,\n  rowIndex: number\n) => {\n  const actions: Array<ActionModel<Field>> = [];\n  const actionLookup = new Set<string>();\n\n  const actionsModel = getActions(dataFrame, field, field.state!.scopedVars!, replaceVars, field.config.actions ?? [], {\n    valueRowIndex: rowIndex,\n  });\n\n  actionsModel.forEach((action) => {\n    const key = `${action.title}`;\n    if (!actionLookup.has(key)) {\n      actions.push(action);\n      actionLookup.add(key);\n    }\n  });\n\n  return actions;\n};\n","import { ReactNode } from 'react';\n\nimport { DataFrame, Field, FieldType, formattedValueToString, InterpolateFunction, LinkModel } from '@grafana/data';\nimport { SortOrder, TooltipDisplayMode } from '@grafana/schema/dist/esm/common/common.gen';\nimport {\n  VizTooltipContent,\n  VizTooltipFooter,\n  VizTooltipHeader,\n  VizTooltipWrapper,\n  getContentItems,\n  VizTooltipItem,\n} from '@grafana/ui/internal';\n\nimport { getFieldActions } from '../status-history/utils';\nimport { fmt } from '../xychart/utils';\n\nimport { isTooltipScrollable } from './utils';\n\n// exemplar / annotation / time region hovering?\n// add annotation UI / alert dismiss UI?\n\nexport interface TimeSeriesTooltipProps {\n  // aligned series frame\n  series: DataFrame;\n\n  // aligned fields that are not series\n  _rest?: Field[];\n\n  // hovered points\n  dataIdxs: Array<number | null>;\n  // closest/hovered series\n  seriesIdx?: number | null;\n  mode?: TooltipDisplayMode;\n  sortOrder?: SortOrder;\n\n  isPinned: boolean;\n\n  annotate?: () => void;\n  maxHeight?: number;\n\n  replaceVariables?: InterpolateFunction;\n  dataLinks: LinkModel[];\n  hideZeros?: boolean;\n}\n\nexport const TimeSeriesTooltip = ({\n  series,\n  _rest,\n  dataIdxs,\n  seriesIdx,\n  mode = TooltipDisplayMode.Single,\n  sortOrder = SortOrder.None,\n  isPinned,\n  annotate,\n  maxHeight,\n  replaceVariables = (str) => str,\n  dataLinks,\n  hideZeros,\n}: TimeSeriesTooltipProps) => {\n  const xField = series.fields[0];\n  const xVal = formattedValueToString(xField.display!(xField.values[dataIdxs[0]!]));\n\n  const contentItems = getContentItems(\n    series.fields,\n    xField,\n    dataIdxs,\n    seriesIdx,\n    mode,\n    sortOrder,\n    (field) => field.type === FieldType.number || field.type === FieldType.enum,\n    hideZeros\n  );\n\n  _rest?.forEach((field) => {\n    if (!field.config.custom?.hideFrom?.tooltip) {\n      contentItems.push({\n        label: field.state?.displayName ?? field.name,\n        value: fmt(field, field.values[dataIdxs[0]!]),\n      });\n    }\n  });\n\n  let footer: ReactNode;\n\n  if (seriesIdx != null) {\n    const field = series.fields[seriesIdx];\n    const hasOneClickLink = dataLinks.some((dataLink) => dataLink.oneClick === true);\n\n    if (isPinned || hasOneClickLink) {\n      const dataIdx = dataIdxs[seriesIdx]!;\n      const actions = getFieldActions(series, field, replaceVariables, dataIdx);\n\n      footer = <VizTooltipFooter dataLinks={dataLinks} actions={actions} annotate={annotate} />;\n    }\n  }\n\n  const headerItem: VizTooltipItem | null = xField.config.custom?.hideFrom?.tooltip\n    ? null\n    : {\n        label: xField.type === FieldType.time ? '' : (xField.state?.displayName ?? xField.name),\n        value: xVal,\n      };\n\n  return (\n    <VizTooltipWrapper>\n      {headerItem != null && <VizTooltipHeader item={headerItem} isPinned={isPinned} />}\n      <VizTooltipContent\n        items={contentItems}\n        isPinned={isPinned}\n        scrollable={isTooltipScrollable({ mode, maxHeight })}\n        maxHeight={maxHeight}\n      />\n      {footer}\n    </VizTooltipWrapper>\n  );\n};\n","import {\n  DataFrame,\n  Field,\n  FieldType,\n  getDisplayProcessor,\n  GrafanaTheme2,\n  isBooleanUnit,\n  TimeRange,\n  cacheFieldDisplayNames,\n  applyNullInsertThreshold,\n  nullToValue,\n} from '@grafana/data';\nimport { convertFieldType } from '@grafana/data/internal';\nimport { GraphFieldConfig, LineInterpolation, TooltipDisplayMode, VizTooltipOptions } from '@grafana/schema';\nimport { buildScaleKey } from '@grafana/ui/internal';\n\nimport { HeatmapTooltip } from '../heatmap/panelcfg.gen';\n\ntype ScaleKey = string;\n\n// this will re-enumerate all enum fields on the same scale to create one ordinal progression\n// e.g. ['a','b'][0,1,0] + ['c','d'][1,0,1] -> ['a','b'][0,1,0] + ['c','d'][3,2,3]\nfunction reEnumFields(frames: DataFrame[]): DataFrame[] {\n  let allTextsByKey: Map<ScaleKey, string[]> = new Map();\n\n  let frames2: DataFrame[] = frames.map((frame) => {\n    return {\n      ...frame,\n      fields: frame.fields.map((field) => {\n        if (field.type === FieldType.enum) {\n          let scaleKey = buildScaleKey(field.config, field.type);\n          let allTexts = allTextsByKey.get(scaleKey);\n\n          if (!allTexts) {\n            allTexts = [];\n            allTextsByKey.set(scaleKey, allTexts);\n          }\n\n          let idxs: number[] = field.values.toArray().slice();\n          let txts = field.config.type!.enum!.text!;\n\n          // by-reference incrementing\n          if (allTexts.length > 0) {\n            for (let i = 0; i < idxs.length; i++) {\n              idxs[i] += allTexts.length;\n            }\n          }\n\n          allTexts.push(...txts);\n\n          // shared among all enum fields on same scale\n          field.config.type!.enum!.text! = allTexts;\n\n          return {\n            ...field,\n            values: idxs,\n          };\n\n          // TODO: update displayProcessor?\n        }\n\n        return field;\n      }),\n    };\n  });\n\n  return frames2;\n}\n\n/**\n * Returns null if there are no graphable fields\n */\nexport function prepareGraphableFields(\n  series: DataFrame[],\n  theme: GrafanaTheme2,\n  timeRange?: TimeRange,\n  // numeric X requires a single frame where the first field is numeric\n  xNumFieldIdx?: number\n): DataFrame[] | null {\n  if (!series?.length) {\n    return null;\n  }\n\n  cacheFieldDisplayNames(series);\n\n  let useNumericX = xNumFieldIdx != null;\n\n  // Make sure the numeric x field is first in the frame\n  if (xNumFieldIdx != null && xNumFieldIdx > 0) {\n    series = [\n      {\n        ...series[0],\n        fields: [series[0].fields[xNumFieldIdx], ...series[0].fields.filter((f, i) => i !== xNumFieldIdx)],\n      },\n    ];\n  }\n\n  // some datasources simply tag the field as time, but don't convert to milli epochs\n  // so we're stuck with doing the parsing here to avoid Moment slowness everywhere later\n  // this mutates (once)\n  for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.time && typeof field.values[0] !== 'number') {\n        field.values = convertFieldType(field, { destinationType: FieldType.time }).values;\n      }\n    }\n  }\n\n  let enumFieldsCount = 0;\n\n  loopy: for (let frame of series) {\n    for (let field of frame.fields) {\n      if (field.type === FieldType.enum && ++enumFieldsCount > 1) {\n        series = reEnumFields(series);\n        break loopy;\n      }\n    }\n  }\n\n  let copy: Field;\n\n  const frames: DataFrame[] = [];\n\n  for (let frame of series) {\n    const fields: Field[] = [];\n\n    let hasTimeField = false;\n    let hasValueField = false;\n\n    let nulledFrame = useNumericX\n      ? frame\n      : applyNullInsertThreshold({\n          frame,\n          refFieldPseudoMin: timeRange?.from.valueOf(),\n          refFieldPseudoMax: timeRange?.to.valueOf(),\n        });\n\n    const frameFields = nullToValue(nulledFrame).fields;\n\n    for (let fieldIdx = 0; fieldIdx < (frameFields?.length || 0); fieldIdx++) {\n      const field = frameFields[fieldIdx];\n\n      switch (field.type) {\n        case FieldType.time:\n          hasTimeField = true;\n          fields.push(field);\n          break;\n        case FieldType.number:\n          hasValueField = useNumericX ? fieldIdx > 0 : true;\n          copy = {\n            ...field,\n            values: field.values.map((v) => {\n              if (!(Number.isFinite(v) || v == null)) {\n                return null;\n              }\n              return v;\n            }),\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.enum:\n          hasValueField = true;\n        case FieldType.string:\n          copy = {\n            ...field,\n            values: field.values,\n          };\n\n          fields.push(copy);\n          break; // ok\n        case FieldType.boolean:\n          hasValueField = true;\n          const custom: GraphFieldConfig = field.config?.custom ?? {};\n          const config = {\n            ...field.config,\n            max: 1,\n            min: 0,\n            custom,\n          };\n\n          // smooth and linear do not make sense\n          if (custom.lineInterpolation !== LineInterpolation.StepBefore) {\n            custom.lineInterpolation = LineInterpolation.StepAfter;\n          }\n\n          copy = {\n            ...field,\n            config,\n            type: FieldType.number,\n            values: field.values.map((v) => {\n              if (v == null) {\n                return v;\n              }\n              return Boolean(v) ? 1 : 0;\n            }),\n          };\n\n          if (!isBooleanUnit(config.unit)) {\n            config.unit = 'bool';\n            copy.display = getDisplayProcessor({ field: copy, theme });\n          }\n\n          fields.push(copy);\n          break;\n      }\n    }\n\n    if ((useNumericX || hasTimeField) && hasValueField) {\n      frames.push({\n        ...frame,\n        length: nulledFrame.length,\n        fields,\n      });\n    }\n  }\n\n  if (frames.length) {\n    setClassicPaletteIdxs(frames, theme, 0);\n    matchEnumColorToSeriesColor(frames, theme);\n    return frames;\n  }\n\n  return null;\n}\n\nconst matchEnumColorToSeriesColor = (frames: DataFrame[], theme: GrafanaTheme2) => {\n  const { palette } = theme.visualization;\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.type === FieldType.enum) {\n        const namedColor = palette[field.state?.seriesIndex! % palette.length];\n        const hexColor = theme.visualization.getColorByName(namedColor);\n        const enumConfig = field.config.type!.enum!;\n\n        enumConfig.color = Array(enumConfig.text!.length).fill(hexColor);\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    }\n  }\n};\n\nexport const setClassicPaletteIdxs = (frames: DataFrame[], theme: GrafanaTheme2, skipFieldIdx?: number) => {\n  let seriesIndex = 0;\n  frames.forEach((frame) => {\n    frame.fields.forEach((field, fieldIdx) => {\n      if (\n        fieldIdx !== skipFieldIdx &&\n        (field.type === FieldType.number || field.type === FieldType.boolean || field.type === FieldType.enum)\n      ) {\n        field.state = {\n          ...field.state,\n          seriesIndex: seriesIndex++, // TODO: skip this for fields with custom renderers (e.g. Candlestick)?\n        };\n        field.display = getDisplayProcessor({ field, theme });\n      }\n    });\n  });\n};\n\nexport function getTimezones(timezones: string[] | undefined, defaultTimezone: string): string[] {\n  if (!timezones || !timezones.length) {\n    return [defaultTimezone];\n  }\n  return timezones.map((v) => (v?.length ? v : defaultTimezone));\n}\n\nexport const isTooltipScrollable = (tooltipOptions: VizTooltipOptions | HeatmapTooltip) => {\n  return tooltipOptions.mode === TooltipDisplayMode.Multi && tooltipOptions.maxHeight != null;\n};\n","// Code generated - EDITING IS FUTILE. DO NOT EDIT.\n//\n// Generated by:\n//     public/app/plugins/gen.go\n// Using jennies:\n//     TSTypesJenny\n//     PluginTsTypesJenny\n//\n// Run 'make gen-cue' from repository root to regenerate.\n\nimport * as common from '@grafana/schema';\n\nexport enum PointShape {\n  Circle = 'circle',\n  Square = 'square',\n}\n\nexport enum SeriesMapping {\n  Auto = 'auto',\n  Manual = 'manual',\n}\n\nexport enum XYShowMode {\n  Lines = 'lines',\n  Points = 'points',\n  PointsAndLines = 'points+lines',\n}\n\n/**\n * NOTE: (copied from dashboard_kind.cue, since not exported)\n * Matcher is a predicate configuration. Based on the config a set of field(s) or values is filtered in order to apply override / transformation.\n * It comes with in id ( to resolve implementation from registry) and a configuration thats specific to a particular matcher type.\n */\nexport interface MatcherConfig {\n  /**\n   * The matcher id. This is used to find the matcher implementation from registry.\n   */\n  id: string;\n  /**\n   * The matcher options. This is specific to the matcher implementation.\n   */\n  options?: unknown;\n}\n\nexport const defaultMatcherConfig: Partial<MatcherConfig> = {\n  id: '',\n};\n\nexport interface FieldConfig extends common.HideableFieldConfig, common.AxisConfig {\n  fillOpacity?: number;\n  lineStyle?: common.LineStyle;\n  lineWidth?: number;\n  pointShape?: PointShape;\n  pointSize?: {\n    fixed?: number;\n    min?: number;\n    max?: number;\n  };\n  pointStrokeWidth?: number;\n  show?: XYShowMode;\n}\n\nexport const defaultFieldConfig: Partial<FieldConfig> = {\n  fillOpacity: 50,\n  show: XYShowMode.Points,\n};\n\nexport interface XYSeriesConfig {\n  color?: {\n    matcher: MatcherConfig;\n  };\n  frame?: {\n    matcher: MatcherConfig;\n  };\n  name?: {\n    fixed?: string;\n  };\n  size?: {\n    matcher: MatcherConfig;\n  };\n  x?: {\n    matcher: MatcherConfig;\n  };\n  y?: {\n    matcher: MatcherConfig;\n  };\n}\n\nexport interface Options extends common.OptionsWithLegend, common.OptionsWithTooltip {\n  mapping: SeriesMapping;\n  series: Array<XYSeriesConfig>;\n}\n\nexport const defaultOptions: Partial<Options> = {\n  series: [],\n};\n","import {\n  Field,\n  formattedValueToString,\n  getFieldMatcher,\n  FieldType,\n  getFieldDisplayName,\n  DataFrame,\n  FrameMatcherID,\n  MatcherConfig,\n  FieldColorModeId,\n  cacheFieldDisplayNames,\n  FieldMatcherID,\n  FieldConfigSource,\n} from '@grafana/data';\nimport { decoupleHideFromState } from '@grafana/data/internal';\nimport { config } from '@grafana/runtime';\nimport { VisibilityMode } from '@grafana/schema';\n\nimport { XYShowMode, SeriesMapping, XYSeriesConfig } from './panelcfg.gen';\nimport { XYSeries } from './types2';\n\nexport function fmt(field: Field, val: number): string {\n  if (field.display) {\n    return formattedValueToString(field.display(val));\n  }\n\n  return `${val}`;\n}\n\n// cause we dont have a proper matcher for this currently\nfunction getFrameMatcher2(config: MatcherConfig) {\n  if (config.id === FrameMatcherID.byIndex) {\n    return (frame: DataFrame, index: number) => index === config.options;\n  }\n\n  return () => false;\n}\n\nexport function prepSeries(\n  mapping: SeriesMapping,\n  mappedSeries: XYSeriesConfig[],\n  frames: DataFrame[],\n  fieldConfig: FieldConfigSource\n) {\n  cacheFieldDisplayNames(frames);\n  decoupleHideFromState(frames, fieldConfig);\n\n  let series: XYSeries[] = [];\n\n  if (mappedSeries.length === 0) {\n    mappedSeries = [{}];\n  }\n\n  const { palette, getColorByName } = config.theme2.visualization;\n\n  mappedSeries.forEach((seriesCfg, seriesIdx) => {\n    if (mapping === SeriesMapping.Manual) {\n      if (seriesCfg.frame?.matcher == null || seriesCfg.x?.matcher == null || seriesCfg.y?.matcher == null) {\n        return;\n      }\n    }\n\n    let xMatcher = getFieldMatcher(\n      seriesCfg.x?.matcher ?? {\n        id: FieldMatcherID.byTypes,\n        options: new Set(['number', 'time']),\n      }\n    );\n    let yMatcher = getFieldMatcher(\n      seriesCfg.y?.matcher ?? {\n        id: FieldMatcherID.byType,\n        options: 'number',\n      }\n    );\n    let colorMatcher = seriesCfg.color ? getFieldMatcher(seriesCfg.color.matcher) : null;\n    let sizeMatcher = seriesCfg.size ? getFieldMatcher(seriesCfg.size.matcher) : null;\n    // let frameMatcher = seriesCfg.frame ? getFrameMatchers(seriesCfg.frame) : null;\n    let frameMatcher = seriesCfg.frame ? getFrameMatcher2(seriesCfg.frame.matcher) : null;\n\n    // loop over all frames and fields, adding a new series for each y dim\n    frames.forEach((frame, frameIdx) => {\n      // must match frame in manual mode\n      if (frameMatcher != null && !frameMatcher(frame, frameIdx)) {\n        return;\n      }\n\n      // shared across each series in this frame\n      let restFields: Field[] = [];\n\n      let frameSeries: XYSeries[] = [];\n\n      let onlyNumTimeFields = frame.fields.filter(\n        (field) => field.type === FieldType.number || field.type === FieldType.time\n      );\n\n      // only one of these per frame\n      let x = onlyNumTimeFields.find((field) => xMatcher(field, frame, frames));\n\n      // only grabbing number fields (exclude time, string, enum, other)\n      let onlyNumFields = onlyNumTimeFields.filter((field) => field.type === FieldType.number);\n\n      let color =\n        colorMatcher != null\n          ? onlyNumFields.find((field) => field !== x && colorMatcher!(field, frame, frames))\n          : undefined;\n      let size =\n        sizeMatcher != null\n          ? onlyNumFields.find((field) => field !== x && field !== color && sizeMatcher!(field, frame, frames))\n          : undefined;\n\n      // x field is required\n      if (x != null) {\n        // match y fields and create series\n        onlyNumFields.forEach((field) => {\n          if (field === x) {\n            return;\n          }\n\n          // in auto mode don't reuse already-mapped fields\n          if (mapping === SeriesMapping.Auto && (field === color || field === size)) {\n            return;\n          }\n\n          // in manual mode only add single series for this config\n          if (mapping === SeriesMapping.Manual && frameSeries.length > 0) {\n            return;\n          }\n\n          // if we match non-excluded y, create series\n          if (yMatcher(field, frame, frames) && !field.config.custom?.hideFrom?.viz) {\n            let y = field;\n\n            let name = seriesCfg.name?.fixed;\n\n            if (name == null) {\n              // if the displayed field name is likely to have a common prefix or suffix\n              // (such as those from Partition by values transformation)\n              const likelyHasCommonParts =\n                frames.length > 1 && (frame.name != null || Object.keys(y.labels ?? {}).length > 0);\n\n              // if the field was explictly (re)named using config.displayName or config.displayNameFromDS\n              // we still want to retain any frame name prefix or suffix so that autoNameSeries() can\n              // properly detect + strip common parts across all series...\n              const { displayName, displayNameFromDS } = y.config;\n              const hasExplicitName = displayName != null || displayNameFromDS != null;\n\n              if (likelyHasCommonParts && hasExplicitName) {\n                // ...and a hacky way to do this is to temp remove the explicit name, get the auto name, then revert\n                const stateDisplayName = y.state!.displayName;\n\n                // clear config and cache\n                y.config.displayName = y.config.displayNameFromDS = y.state!.displayName = undefined;\n                // get default/calculated display name (maybe use calculateFieldDisplayName() here instead?)\n                name = getFieldDisplayName(y, frame, frames);\n                // replace original field name with explicit one\n                name = name.replace(y.name, (displayNameFromDS ?? displayName)!);\n\n                // revert\n                y.config.displayName = displayName;\n                y.config.displayNameFromDS = displayNameFromDS;\n                y.state!.displayName = stateDisplayName;\n              } else {\n                name = getFieldDisplayName(y, frame, frames);\n              }\n            }\n\n            let ser: XYSeries = {\n              // these typically come from y field\n              name: {\n                value: name,\n              },\n\n              showPoints: y.config.custom.show === XYShowMode.Lines ? VisibilityMode.Never : VisibilityMode.Always,\n              pointShape: y.config.custom.pointShape,\n              pointStrokeWidth: y.config.custom.pointStrokeWidth,\n              fillOpacity: y.config.custom.fillOpacity,\n\n              showLine: y.config.custom.show !== XYShowMode.Points,\n              lineWidth: y.config.custom.lineWidth ?? 2,\n              lineStyle: y.config.custom.lineStyle,\n\n              x: {\n                field: x!,\n              },\n              y: {\n                field: y,\n              },\n              color: {},\n              size: {},\n              _rest: restFields,\n            };\n\n            if (color != null) {\n              ser.color.field = color;\n            }\n\n            if (size != null) {\n              ser.size.field = size;\n              ser.size.min = size.config.custom.pointSize?.min ?? 5;\n              ser.size.max = size.config.custom.pointSize?.max ?? 100;\n              // ser.size.mode =\n            }\n\n            frameSeries.push(ser);\n          }\n        });\n\n        if (frameSeries.length === 0) {\n          // TODO: could not create series, skip & show error?\n        }\n\n        // populate rest fields\n        frame.fields.forEach((field) => {\n          let isUsedField = frameSeries.some(\n            ({ x, y, color, size }) =>\n              x.field === field || y.field === field || color.field === field || size.field === field\n          );\n\n          if (!isUsedField) {\n            restFields.push(field);\n          }\n        });\n\n        series.push(...frameSeries);\n      } else {\n        // x is missing in this frame!\n      }\n    });\n  });\n\n  if (series.length === 0) {\n    // TODO: could not create series, skip & show error?\n  } else {\n    // assign classic palette colors by index, as fallbacks for all series\n\n    let paletteIdx = 0;\n\n    // todo: populate min, max, mode from field + hints\n    series.forEach((s, i) => {\n      if (s.color.field == null) {\n        // derive fixed color from y field config\n        let colorCfg = s.y.field.config.color ?? { mode: FieldColorModeId.PaletteClassic };\n\n        let value = '';\n\n        if (colorCfg.mode === FieldColorModeId.PaletteClassic) {\n          value = getColorByName(palette[paletteIdx++ % palette.length]); // todo: do this via state.seriesIdx and re-init displayProcessor\n        } else if (colorCfg.mode === FieldColorModeId.Fixed) {\n          value = getColorByName(colorCfg.fixedColor!);\n        }\n\n        s.color.fixed = value;\n      }\n\n      if (s.size.field == null) {\n        // derive fixed size from y field config\n        s.size.fixed = s.y.field.config.custom.pointSize?.fixed ?? 5;\n        // ser.size.mode =\n      }\n    });\n\n    autoNameSeries(series);\n\n    // TODO: re-assign y display names?\n    // y.state = {\n    //   ...y.state,\n    //   seriesIndex: series.length + ,\n    // };\n    // y.display = getDisplayProcessor({ field, theme });\n  }\n\n  return series;\n}\n\n// strip common prefixes and suffixes from y field names\nfunction autoNameSeries(series: XYSeries[]) {\n  let names = series.map((s) => s.name.value.split(/\\s+/g));\n\n  const { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  if (prefix < Infinity || suffix < Infinity) {\n    series.forEach((s, i) => {\n      s.name.value = names[i].slice(prefix, names[i].length - suffix).join(' ');\n    });\n  }\n}\n\nexport function getCommonPrefixSuffix(strs: string[]) {\n  let names = strs.map((s) => s.split(/\\s+/g));\n\n  let { prefix, suffix } = findCommonPrefixSuffixLengths(names);\n\n  let n = names[0];\n\n  if (n.length === 1 && prefix === 1 && suffix === 1) {\n    return '';\n  }\n\n  let parts = [];\n\n  if (prefix > 0) {\n    parts.push(...n.slice(0, prefix));\n  }\n\n  if (suffix > 0) {\n    parts.push(...n.slice(-suffix));\n  }\n\n  return parts.join(' ');\n}\n\n// lengths are in number of tokens (segments) in a phrase\nfunction findCommonPrefixSuffixLengths(names: string[][]) {\n  let commonPrefixLen = Infinity;\n  let commonSuffixLen = Infinity;\n\n  // if auto naming strategy, rename fields by stripping common prefixes and suffixes\n  let segs0: string[] = names[0];\n\n  for (let i = 1; i < names.length; i++) {\n    if (names[i].length < segs0.length) {\n      segs0 = names[i];\n    }\n  }\n\n  for (let i = 1; i < names.length; i++) {\n    let segs = names[i];\n\n    if (segs !== segs0) {\n      // prefixes\n      let preLen = 0;\n      for (let j = 0; j < segs0.length; j++) {\n        if (segs[j] === segs0[j]) {\n          preLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (preLen < commonPrefixLen) {\n        commonPrefixLen = preLen;\n      }\n\n      // suffixes\n      let sufLen = 0;\n      for (let j = segs0.length - 1; j >= 0; j--) {\n        if (segs[j] === segs0[j]) {\n          sufLen++;\n        } else {\n          break;\n        }\n      }\n\n      if (sufLen < commonSuffixLen) {\n        commonSuffixLen = sufLen;\n      }\n    }\n  }\n\n  return {\n    prefix: commonPrefixLen,\n    suffix: commonSuffixLen,\n  };\n}\n"],"names":["VizTooltipContent","items","children","isPinned","scrollable","maxHeight","styles","getStyles","scrollableStyle","label","value","color","colorIndicator","colorPlacement","isActive","lineStyle","i","theme","VizTooltipHeader","item","ColorIndicatorPosition","VizTooltipColorIndicator","position","SeriesIcon","LabelValueTypes","SUCCESSFULLY_COPIED_TEXT","SHOW_SUCCESS_DURATION","HORIZONTAL_PX_PER_CHAR","VizTooltipRow","justify","marginRight","showValueScroll","innerValueScrollStyle","showLabelTooltip","setShowLabelTooltip","copiedText","setCopiedText","showCopySuccess","setShowCopySuccess","labelRef","valueRef","timeoutId","copyToClipboard","text","type","fallbackCopyToClipboard","textarea","err","onMouseEnterLabel","event","onMouseLeaveLabel","Tooltip","InlineToast","genReplaceActionVars","boundReplaceVariables","action","actionVars","scopedVars","format","matched","name","getActions","frame","field","fieldScopedVars","replaceVariables","actions","config","dataContext","actionScopedVars","evt","origin","request","buildActionRequest","error","url","getUrl","requestHeaders","getData","getActionsDefaultField","dataLinks","endpoint","sanitizedRelativeURL","data","hasVisibleLegendSeries","BarChartLegend","placement","calcs","displayMode","colorField","vizLayoutLegendProps","fieldConfig","colorMode","thresholdItems","thresholdsAbsolute","thresholdsPercent","step","thresholdAbsoluteItems","thresholdPercentItems","valueMappings","mappings","mapping","valueMappingItems","legendItems","fieldIndex","VizLayout","VizLegend","intervals","groupDistr","barDistr","VALUE_MIN_FONT_SIZE","VALUE_MAX_FONT_SIZE","BAR_FONT_SIZE_RATIO","LABEL_OFFSET_FACTOR_VT","LABEL_OFFSET_FACTOR_HZ","LABEL_OFFSET_MAX_VT","LABEL_OFFSET_MAX_HZ","MIDDLE_BASELINE_SHIFT","calculateFontSizeWithMetrics","width","height","lineHeight","maxSize","textSize","measureText","fontSizeBasedOnWidth","fontSizeBasedOnHeight","optimalSize","getConfig","opts","xOri","dir","rawValue","getColor","formatValue","formatShortValue","fillOpacity","showValue","xSpacing","hoverMulti","timeZone","isXHorizontal","hasAutoValueSize","isStacked","pctStacked","groupWidth","barWidth","barRadius","qt","hovered","hRect","xSplits","v","hFilter","splits","dim","_dir","dataLen","lastIdx","skipMod","cssDim","maxTicks","splits2","xValues","axisIdx","foundSpace","foundIncr","xRange","min","max","pctOffset","distribute","di","lftPct","widPct","rn","offset","distrTwo","groupCount","barCount","out","groupIdx","groupOffPct","groupDimPct","barIdx","barOffPct","barDimPct","distrOne","LABEL_OFFSET_FACTOR","LABEL_OFFSET_MAX","barsPctLayout","barsColors","scaleFactor","labels","fontSize","labelOffset","vSpace","hSpace","useMappedColors","mappedColorDisp","seriesIdx","barsBuilder","dataIdx","lft","top","wid","hgt","val","barRect","raw","divider","alignedTotals","calculatedSize","textMetrics","autoFontSize","middleShift","x","y","xAdjust","yAdjust","init","el","cursor","cx","cy","o","r","hRect2","isHovered","drawClear","s","colors","valueIdx","c","colorManipulator","draw","curAlign","curBaseline","didx","first","sidx","align","baseline","bbox","intersectsLabel","subsidx","label2","bbox2","hidden","prepData","frames","stackingGroups","totals","defaultOptions","defaultFieldConfig","prepSeries","stacking","xFieldName","colorFieldName","fr","timeFieldIdx","f","xField","fields","_rest","field2","warn","series","prepConfig","totalSeries","orientation","options","tooltip","xTickLabelRotation","xTickLabelMaxLength","xTickLabelSpacing","legend","fullHighlight","builder","UPlotConfigBuilder","formatters","shortenValue","vizOrientation","getScaleOrientation","disp","m","result","lftSpace","btmSpace","getRotationPadding","xFieldAxisPlacement","xFieldAxisShow","customConfig","scaleKey","seriesColor","softMin","softMax","axisOpts","decimals","_series","_color","length","rotateLabel","valueMaxLength","values","displayProcessor","getProcessedValue","maxLength","size","paddingRight","paddingLeft","paddingBottom","charWidth","toRads","BarChartPanel","props","id","colorByField","info","vizSeries","xGroupsCount","seriesCount","plotData","PanelDataErrorView","legendComp","vizWidth","vizHeight","TooltipPlugin2","u","dataIdxs","dismiss","timeRange2","viaSync","TimeSeriesTooltip","TickSpacingEditor","GAPS_OPTIONS","isRTL","gap","onSpacingChange","onRTLChange","RadioButtonGroup","Checkbox","changeToBarChartPanelMigrationHandler","panel","prevPluginId","prevOptions","graphOptions","transformations","getReducer","reducers","transformReducers","reducer","BarChartSuggestionsSupplier","list","dataSummary","PanelPlugin","cfg","ThresholdsStyleEditor","countNumberFields","count","HorizontalConstraint","VerticalConstraint","BackgroundImageSize","HttpRequestMethod","ConnectionPath","defaultCanvasConnection","defaultCanvasElementOptions","getDataLinks","rowIdx","links","linkLookup","link","key","getAllFrameActions","dataFrame","getFieldActions","replaceVars","rowIndex","actionLookup","mode","sortOrder","annotate","str","hideZeros","xVal","contentItems","footer","hasOneClickLink","dataLink","headerItem","reEnumFields","allTextsByKey","allTexts","idxs","txts","prepareGraphableFields","timeRange","xNumFieldIdx","useNumericX","enumFieldsCount","loopy","copy","hasTimeField","hasValueField","nulledFrame","frameFields","fieldIdx","custom","setClassicPaletteIdxs","matchEnumColorToSeriesColor","palette","namedColor","hexColor","enumConfig","skipFieldIdx","seriesIndex","getTimezones","timezones","defaultTimezone","isTooltipScrollable","tooltipOptions","PointShape","SeriesMapping","XYShowMode","defaultMatcherConfig","fmt","getFrameMatcher2","index","mappedSeries","getColorByName","seriesCfg","xMatcher","yMatcher","colorMatcher","sizeMatcher","frameMatcher","frameIdx","restFields","frameSeries","onlyNumTimeFields","onlyNumFields","likelyHasCommonParts","displayName","displayNameFromDS","hasExplicitName","stateDisplayName","ser","paletteIdx","colorCfg","autoNameSeries","names","prefix","suffix","findCommonPrefixSuffixLengths","getCommonPrefixSuffix","strs","n","parts","commonPrefixLen","commonSuffixLen","segs0","segs","preLen","j","sufLen"],"sourceRoot":""}